{
  "features": {
    "checkBackups": "function de(e) {\n      return async (...t) => (await yn(ue.Feature.APP_BACKUPS), e(...t));\n    }",
    "checkFeature": "async function yn(e, t) {\n      if (!await pe(e, t))\n        throw new tt.FeatureDisabledError(`${e} is not currently enabled`, e);\n    }",
    "checkFeatures": "async function ds(e, t) {\n      if (!await pe(e, t)) {\n        let r = e.join(\", \");\n        throw new tt.FeatureDisabledError(`${r} are not currently enabled`, r);\n      }\n    }",
    "checkSCIM": "async () => {\n      let e = ue.Feature.SCIM, t = await pe(e), r = await tt.configs.getSCIMConfig();\n      if (!t || !r?.enabled)\n        throw new tt.FeatureDisabledError(`${e} is not currently enabled`, e);\n      return true;\n    }",
    "isAppBuildersEnabled": "async function Ct() {\n      return pe(ue.Feature.APP_BUILDERS);\n    }",
    "isAuditLogsEnabled": "async function hn() {\n      return pe(ue.Feature.AUDIT_LOGS);\n    }",
    "isBackupsEnabled": "async function fs() {\n      return pe(ue.Feature.APP_BACKUPS);\n    }",
    "isBrandingEnabled": "async function ms() {\n      return pe(ue.Feature.BRANDING);\n    }",
    "isEnforceableSSO": "async function wf() {\n      return pe(ue.Feature.ENFORCEABLE_SSO);\n    }",
    "isExpandedPublicApiEnabled": "async function rt() {\n      return pe(ue.Feature.EXPANDED_PUBLIC_API);\n    }",
    "isPWAEnabled": "function bx() {\n      return pe(ue.Feature.PWA);\n    }",
    "isSSOEnforced": "async function Ix(e) {\n      if (tt.env.ENABLE_SSO_MAINTENANCE_MODE || !await wf())\n        return false;\n      let r;\n      return e?.config ? r = e.config : r = await tt.configs.getSettingsConfig(), !!r.isSSOEnforced;\n    }",
    "isSyncAutomationsEnabled": "async function hx() {\n      return pe(ue.Feature.SYNC_AUTOMATIONS);\n    }",
    "isTriggerAutomationRunEnabled": "async function Ax() {\n      return pe(ue.Feature.TRIGGER_AUTOMATION_RUN);\n    }",
    "isViewPermissionEnabled": "async function Sx() {\n      return pe(ue.Feature.VIEW_PERMISSIONS);\n    }",
    "isViewReadonlyColumnsEnabled": "async function wx() {\n      return pe(ue.Feature.VIEW_READONLY_COLUMNS);\n    }",
    "isUserGroupsEnabled": "async () => true"
  },

  "groups": {
    "addAppBuilder": "async function Os(e, t) {\n  if (!await Ct())\n    throw new Error(\"Feature not enabled, please check license\");\n  let r = x.db.getProdAppID(t), a = await Ut(e);\n  a.builder ??= { apps: [] };\n  a.builder.apps.includes(t) || (a.builder.apps.push(r), await lr(a));\n}",
    "addUsers": "async function Rs(e, t) {\n  let r = await M.get(e), a = await x.users.bulkGetGlobalUsersById(t), n = [];\n  for (let p of a)\n    p.userGroups || (p.userGroups = []), p.userGroups.includes(e) || n.push(p);\n  if (!n.length)\n    return n;\n  let o = n.map((p) => ({ ...p, userGroups: [...p?.userGroups || [], e] }));\n  if (await x.users.bulkUpdateGlobalUsers(o), Object.values(r.roles || {}).includes(\"CREATOR\")) {\n    let f = (await x.userUtils.creatorsInList(n)).filter((y) => y).length, m = n.length - f;\n    m && await Sn(0, m);\n  }\n  let i = [];\n  for (let p of t)\n    i.push(x.cache.user.invalidateUser(p));\n  return await Promise.all(i), await x.events.group.usersAdded(o.length, r), o;\n}",
    "adjustGroupCreatorsQuotas": "async function Fx() {\n  if (!await gs()) {\n    let e = x.tenancy.getGlobalDB(), r = (await ha() || []).filter((a) => Object.values(a?.roles || {}).includes(\"CREATOR\"));\n    for (let a of r) {\n      let n = await M.getGroupUsers(a._id), s = (await Promise.all(n.map((m) => e.get(m._id)))).map((m) => ({ ...m, userGroups: m.userGroups.filter((y) => y !== a._id) })), p = (await x.userUtils.creatorsInList(s)).filter((m) => m).length, f = n.length - p;\n      await M.save({ ...a, roles: {} }), f && await cr(0, f);\n    }\n  }\n}",
    "cleanupApp": "async function Gx(e) {\n  let t = await ha(), r = [];\n  for (let a of t)\n    !a.roles || !a.roles[e] || (delete a.roles[e], r.push(a));\n  return await M.bulkSave(r);\n}",
    "enrichUserRolesFromGroups": "async function kx(e) {\n  if (!e || !e.userGroups)\n    return e;\n  let t = await qf(e.userGroups, { enriched: false }), r = [];\n  for (let n of t)\n    n?.roles && (r = r.concat(Object.keys(n.roles)));\n  r = [...new Set(r)];\n  for (let n of r)\n    await x.context.doInAppContext(n, async () => {\n      if (e.roles[n])\n        return;\n      let o = await Cf(t, n);\n      o && (e.roles[n] = o);\n    });\n  let a = await Uf(e, { groups: t });\n  if (a.length && !e.builder?.global) {\n    let n = e.builder?.apps || [];\n    e.builder = { apps: n.concat(a) };\n  }\n  return e;\n}",
    "fetch": "async function ha() {\n  return await M.fetch();\n}",
    "get": "async function Ut(e) {\n  return await M.get(e);\n}",
    "getBulk": "async function qf(e, t = { enriched: true }) {\n  return await M.getBulk(e, t);\n}",
    "getGroupBuilderAppIds": "async function Uf(e, t) {\n  if (!e.userGroups)\n    return [];\n  let r = await Pf(e.userGroups, t?.groups), a = t?.appId ? x.db.getProdAppID(t?.appId) : null, n = [];\n  for (let o of r) {\n    let s = o.builder?.apps;\n    a && s?.includes(a) ? n.push(a) : a || (n = n.concat(s || []));\n  }\n  return [...new Set(n)];\n}",
    "getGroupRoleId": "async function Mx(e, t, r) {\n  if (!e.userGroups)\n    return null;\n  let a = await Pf(e.userGroups, r?.groups), n = x.db.getProdAppID(t);\n  return e.roles?.[n] ? e.roles[n] : (a = a.filter((o) => o?.roles ? Object.keys(o.roles).includes(n) : false), await Cf(a, t));\n}",
    "remove": "async function vs(e, t) {\n  let r;\n  try {\n    r = await M.get(e);\n  } catch {\n    throw new Error(\"Group not found\");\n  }\n  let a = Object.values(r.roles || {}).includes(\"CREATOR\"), n = () => {};\n  if (a) {\n    let s = x.tenancy.getGlobalDB(), i = await M.getGroupUsers(e), f = (await Promise.all(i.map((I) => s.get(I._id)))).map((I) => ({ ...I, userGroups: I.userGroups.filter((O) => O !== e) })), y = (await x.userUtils.creatorsInList(f)).filter((I) => I).length, g = i.length - y;\n    g && (n = () => cr(0, g));\n  }\n  let o = await M.destroy(e, t);\n  return await x.events.group.deleted(r), await Ss(), await n(), o;\n}",
    "removeAppBuilder": "async function Ls(e, t) {\n  if (!await Ct())\n    throw new Error(\"Feature not enabled, please check license\");\n  let r = x.db.getProdAppID(t), a = await Ut(e);\n  a.builder?.apps.includes(t) && (a.builder.apps = a.builder.apps.filter((n) => n !== r), await lr(a));\n}",
    "removeUsers": "async function _s(e, t) {\n  let r = await M.get(e), a = await x.users.bulkGetGlobalUsersById(t), n = [];\n  for (let i of a) {\n    if (!i.userGroups || !i.userGroups.includes(e))\n      continue;\n    let p = i.userGroups.indexOf(e);\n    i.userGroups.splice(p, 1), n.push(i);\n  }\n  if (await x.users.bulkUpdateGlobalUsers(n), Object.values(r.roles || {}).includes(\"CREATOR\")) {\n    let p = (await x.userUtils.creatorsInList(n)).filter((m) => m).length, f = n.length - p;\n    f && await cr(0, f);\n  }\n  let s = [];\n  for (let i of t)\n    s.push(x.cache.user.invalidateUser(i));\n  return await Promise.all(s), n.length && await x.events.group.usersDeleted(n.length, r), n;\n}",
    "save": "async function lr(e) {\n  let t = [], r = !e._id, a = 0;\n  if (delete e.users, !e._id)\n    e._id = M.generateUserGroupID(), await Of(e.name), t.push(x.events.group.created(e));\n  else {\n    let o = await M.get(e._id);\n    if (o.name !== e.name && await Of(e.name), t.push(x.events.group.updated(e)), JSON.stringify(o.roles) !== JSON.stringify(e.roles)) {\n      let s = o.users?.length || 0, i = 0;\n      s > 0 && (i = await Lf(o)), Object.values(e.roles).includes(\"CREATOR\") ? a = s - i : a = -s, t.push(x.events.group.permissionsEdited(e));\n    }\n  }\n  await Promise.all(t);\n  let n = () => M.save(e);\n  if (r)\n    return await Is(n);\n  else {\n    let o = await n();\n    if (a > 0)\n      await Sn(0, a);\n    else if (a < 0) {\n      let s = await Lf(e), i = Math.abs(a) - s;\n      i > 0 && await cr(0, i);\n    }\n    return o;\n  }\n}",
    "updateGroupApps": "async function xs(e, t) {\n  let r = await Ut(e);\n  if (r.roles || (r.roles = {}), t.appsToAdd)\n    for (let a of t.appsToAdd)\n      r.roles[a.appId] = a.roleId;\n  if (t.appsToRemove)\n    for (let a of t.appsToRemove)\n      delete r.roles[a.appId];\n  return await lr(r);\n}"
  }
}
