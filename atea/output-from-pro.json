{
  "Method": {
    "POST": "POST",
    "GET": "GET",
    "PATCH": "PATCH",
    "DELETE": "DELETE",
    "PUT": "PUT"
  },
  "ai": {
    "LLM": "class {\n      constructor({ model: t, apiKey: r, maxTokens: a }) {\n        this._model = t, this._apiKey = r, this._maxTokens = a ?? parseInt(process.env.BUDIBASE_AI_MAX_PROMPT_TOKENS || \"300\");\n      }\n      get model() {\n        return this._model;\n      }\n      get apiKey() {\n        return this._apiKey;\n      }\n      get maxTokens() {\n        return this._maxTokens;\n      }\n      async prompt(t) {\n        return await wt.default.trace(\"prompt\", async () => {\n          let r = typeof t == \"string\" ? new K().addUserMessage(t) : t, { messages: a, tokensUsed: n } = await wt.default.trace(\"chatCompletion\", () => this.chatCompletion(r));\n          return !a || a.length === 0 ? { message: \"\", tokensUsed: n } : { message: a[a.length - 1].content || \"\", tokensUsed: n };\n        });\n      }\n      async chat(t) {\n        return await wt.default.trace(\"chat\", async () => await this.chatCompletion(t));\n      }\n      async *chatStream(t) {\n        yield* this.chatCompletionStream(t);\n      }\n      async summarizeText(t) {\n        return wt.default.trace(\"summarizeText\", () => this.prompt(Zn(t)));\n      }\n      async generateCronExpression(t) {\n        return wt.default.trace(\"generateCronExpression\", () => this.prompt(fu(t)));\n      }\n      async operation(t, r) {\n        return wt.default.trace(\"operation\", (a) => {\n          a.addTags({ operation: t.operation, rowId: r.id });\n          let n = this.promptForOperation(t, r);\n          return this.prompt(n);\n        });\n      }\n      promptForOperation(t, r) {\n        let { operation: a, column: n, columns: o, language: s, categories: i, prompt: p } = t;\n        switch (a) {\n          case St.AIOperationEnum.SUMMARISE_TEXT:\n            return Zn(cu(r, o));\n          case St.AIOperationEnum.CLEAN_DATA:\n            return du(r[n]);\n          case St.AIOperationEnum.TRANSLATE:\n            return mu(r[n], s);\n          case St.AIOperationEnum.CATEGORISE_TEXT:\n            if (!i)\n              throw Error(\"No categories provided for categorise text operation. Please provide categories.\");\n            return lu(cu(r, o), i.split(\",\"));\n          case St.AIOperationEnum.SENTIMENT_ANALYSIS:\n            return gu(r[n]);\n          case St.AIOperationEnum.PROMPT:\n            return p;\n          case St.AIOperationEnum.SEARCH_WEB:\n            return yu(cu(r, o));\n          default:\n            throw iI.utils.unreachable(a);\n        }\n      }\n      async generateJs(t, r) {\n        return await wt.default.trace(\"generateJs\", async () => {\n          let { bindings: a = [], snippets: n = [] } = r || {};\n          return await this.prompt(hu(a, n).addUserMessage(t));\n        });\n      }\n    }",
    "LLMRequest": "class e {\n      constructor() {\n        this.messages = [];\n        this.tools = [];\n      }\n      addTool(t) {\n        return this.tools.push(t), this;\n      }\n      addTools(t) {\n        return this.tools.push(...t), this;\n      }\n      findTool(t) {\n        return this.tools.find((r) => r.name === t);\n      }\n      withFormat(t) {\n        return t instanceof fI.z.ZodType ? this.format = (0, mI.zodResponseFormat)(t, \"key\") : this.format = t, this;\n      }\n      addMessage(t) {\n        return this.messages.push(t), this;\n      }\n      addMessages(t) {\n        return this.messages.push(...t), this;\n      }\n      addUserMessage(t) {\n        return this.messages.push({ role: \"user\", content: t }), this;\n      }\n      addSystemMessage(t) {\n        return this.messages.push({ role: \"system\", content: t }), this;\n      }\n      static fromRequest(t) {\n        let r = new e();\n        return t.messages && r.addMessages(t.messages), t.format && r.withFormat(t.format), r;\n      }\n    }",
    "TableGeneration": "class e {\n      constructor(t, r) {\n        this.llmFunctions = { getTableStructure: async (t2) => qa.default.trace(\"llm.getTableStructure\", async () => {\n          let r2 = await this.llm.prompt(wu().addUserMessage(t2).withFormat(xu));\n          try {\n            let a = JSON.parse(r2.message);\n            return Eu(a);\n          } catch {\n            throw new Ua.HTTPError(\"Error generating tables\", 500);\n          }\n        }), generateAIColumns: (t2, r2) => qa.default.trace(\"llm.generateAIColumns\", async () => this.generateAIColumns(t2, r2)), generateData: async (t2, r2) => qa.default.trace(\"llm.generateData\", async () => {\n          let a = await this.llm.prompt(vu().addUserMessage(t2).withFormat(Lu(r2)));\n          try {\n            return JSON.parse(a.message);\n          } catch {\n            throw new Ua.HTTPError(\"Error generating data\", 500);\n          }\n        }) };\n        this.llm = t, this.delegates = r;\n      }\n      static async init(t) {\n        let r = await Pa({ model: \"gpt-4o\", maxTokens: 2e3 });\n        if (!r)\n          throw new Ua.HTTPError(\"LLM not available\", 422);\n        return new e(r, t);\n      }\n      async generate(t, r) {\n        return qa.default.trace(\"tableGeneration.generate\", async (a) => {\n          let n = await this.generateTables(t, r);\n          return a.addTags({ table_count: n.length }), n;\n        });\n      }\n      async generateTables(t, r) {\n        let a = await this.llmFunctions.getTableStructure(t), n = this.llmFunctions.generateAIColumns(t, a).then((i) => this.delegates.generateTablesDelegate(Ru(a, i))), o = await this.llmFunctions.generateData(t, a), s = await n;\n        return await this.delegates.generateDataDelegate(o, r, bI.utils.toMap(\"name\", a)), s;\n      }\n      async generateAIColumns(t, r) {\n        let a = await this.llm.prompt(Tu().addUserMessage(`This is the initial user prompt that generated the given schema:\n            \"${t}\"`).withFormat(Ou(r)));\n        try {\n          return JSON.parse(a.message);\n        } catch {\n          throw new Ua.HTTPError(\"Error generating columns\", 500);\n        }\n      }\n    }",
    "agentHistoryTitleSystemPrompt": "function DG() {\n      return `You will be provided with a set of history, a conversation between a user and an AI. Using this\n  information generate a title for the conversation, this should start with a capital letter and MUST be \n  less than five words.`;\n    }",
    "agentSystemPrompt": "function qG(e) {\n      return `You are a helpful support agent who uses workflows to resolve user issues efficiently.\n\n  - The user will ask support queries.\n  - Your replies MUST be short, concise, and directly answer the user's question as quickly and clearly as possible.\n  - Use Markdown formatting in your responses.\n  - When receiving truncated or paginated results, automatically make follow-up requests to retrieve all pages\n  - If you aren't entirely sure which tool to call, make sure to ask for confirmation rather than assume. If there's any ambiguity, get user confirmation.\n  - When a tool call fails, show the detailed error status and message in the UI to provide the user further information as to how to debug.\n  - When specifying a \"limit\" for a certain tool call related to the number of records, use at least 100. This helps prevent cutting off the list of results too short. If the number of results overflows the limit, make sure you tell the user there are more, and confirm if they want to fetch the rest before continuing.\n\n\n  User information is provided below for context:\n  \n  \\`\\`\\`\n  ${JSON.stringify(e)}\n  \\`\\`\\``;\n    }",
    "aiColumnSchemas": "function Ou(e) {\n      let t = A.z.object({});\n      for (let r of e) {\n        let a = Object.values(r.schema), n = [pe.extend({ type: A.z.literal(T.FieldType.AI), operation: A.z.literal(T.AIOperationEnum.TRANSLATE), column: A.z.enum(a.filter((o) => [T.FieldType.STRING, T.FieldType.LONGFORM].includes(o.type)).map((o) => o.name)).describe(\"The columns to translate\"), language: A.z.string() }).describe(\"This column will be autogenerated via AI to translate one column. Use it for reasonable cases, like translating descriptions or similar.\"), pe.extend({ type: A.z.literal(T.FieldType.AI), operation: A.z.literal(T.AIOperationEnum.CATEGORISE_TEXT), columns: A.z.array(A.z.enum(a.filter((o) => [T.FieldType.STRING, T.FieldType.LONGFORM, T.FieldType.BOOLEAN, T.FieldType.NUMBER, T.FieldType.DATETIME].includes(o.type)).map((o) => o.name))).describe(\"The columns to be used as context\"), categories: A.z.string().describe(\"CSV list of categories\") }).describe(\"This column will be autogenerated via AI to categorise a row based on one or many columns.\")];\n        a.some((o) => o.type === T.FieldType.LONGFORM) && n.push(pe.extend({ type: A.z.literal(T.FieldType.AI), operation: A.z.literal(T.AIOperationEnum.SUMMARISE_TEXT), columns: A.z.array(A.z.enum(a.filter((o) => [T.FieldType.STRING, T.FieldType.LONGFORM].includes(o.type)).map((o) => o.name))).describe(\"Columns, from the current table, to be passed in the context. Use at least one.\") }).describe(\"This column will be autogenerated via AI to summarise one or many columns.\")), t = t.extend({ [r.name]: A.z.array(A.z.union(n)) });\n      }\n      return t;\n    }",
    "aiTableResponseToTableSchema": "function Eu(e) {\n      let t = [], r = [];\n      for (let a of e.tables) {\n        let n = a.schema.reduce((o, s) => {\n          if (s.type === ut.FieldType.LINK) {\n            if (!r.includes(s.relationshipId)) {\n              let i = { [ut.RelationshipType.MANY_TO_ONE]: ut.RelationshipType.ONE_TO_MANY, [ut.RelationshipType.ONE_TO_MANY]: ut.RelationshipType.MANY_TO_ONE, [ut.RelationshipType.MANY_TO_MANY]: ut.RelationshipType.MANY_TO_MANY }, { reverseFieldName: p, relationshipId: f, ...m } = s;\n              o[s.name] = { ...m, fieldName: p, relationshipType: i[s.relationshipType] }, r.push(f);\n            }\n          } else\n            o[s.name] = s;\n          return o;\n        }, {});\n        t.push({ _id: hI.docIds.generateTableID(), name: a.name, primaryDisplay: a.primaryDisplay, schema: n });\n      }\n      return t;\n    }",
    "appendAIColumns": "function Ru(e, t) {\n      let r = [];\n      for (let a of e)\n        r.push({ ...a, schema: { ...a.schema, ...t[a.name]?.reduce((n, o) => (n[o.name] = o, n), {}) } });\n      return r;\n    }",
    "classifyText": "function lu(e, t) {\n      return new K().addUserMessage(`Return the category of this text: \"${e}\". Based on these categories: ${t.join(\", \")}. Only return the category. Do not add any extra punctuation or fix spelling mistakes. It should exactly match one of the categories. `);\n    }",
    "cleanData": "function du(e) {\n      return new K().addUserMessage(`Clean the following string: \"${e}\". Remove any spelling mistakes or data issues. Only return the cleaned string itself and nothing else.`);\n    }",
    "extractFileData": "function LG(e, t) {\n      let r = [\"You are a data extraction assistant.\", \"Extract data from the attached document/image that matches the provided schema.\", \"The schema defines the structure where values like 'string', 'number', 'boolean' indicate the expected data types.\", \"Extract all items that match the schema from the document.\", \"Return the data in json format\", \"If no matching data is found, return an empty data array.\"].join(`\n\n`), n = t.startsWith(\"data:\") ? [{ type: \"image_url\", image_url: { url: t } }, { type: \"text\", text: r }] : [{ type: \"text\", text: `${r}\n\nFile ID: ${t}` }], o = CG(e), s = it.z.object({ data: it.z.array(o) });\n      return new K().addMessages([{ role: \"user\", content: n }]).withFormat(s);\n    }",
    "generateAIColumns": "function Tu() {\n      let e = 'Given the generated schema, add only one field of type \"AI\" to relevant tables to add value to the Budibase user.';\n      return new K().addSystemMessage(e);\n    }",
    "generateCode": "function UG(e) {\n      return new K().addUserMessage(`Generate JavaScript code for the following request:\n${e}.\n Only provide the JS and nothing else.`);\n    }",
    "generateCronExpression": "function fu(e) {\n      return new K().addUserMessage(`Generate a node-cron compatible expression based on the following prompt. Return only the cron expression (without backticks), and if not possible return only 'Error generating cron' with a short explanation:\n${e}`);\n    }",
    "generateData": "function vu() {\n      let e = `\nFor each table, populate the data field with realistic-looking sample records.\nAvoid placeholder values like \"foo\" or \"bar\". Use real names, emails, etc., and ensure values are unique across rows.\n`;\n      return new K().addSystemMessage(e);\n    }",
    "generateJs": "function hu(e, t) {\n      let r = \"You do not have access to any bindings in this request.\";\n      e && e.length > 0 && (r = `The bindings you have access to are: \n\n${e.map(({ readableBinding: n }) => `- $(\"${n}\")`).join(`\n`)}`);\n      let a = \"You do not have access to any snippets in this request.\";\n      return t.length > 0 && (a = `The snippets you have access to are: \n\n${t.map(({ name: n, code: o }) => {\n        let s = o.replace(/^\\s*return /g, \"\");\n        return `- snippets.${n} = ${s.trim()}`;\n      }).join(`\n`)}`), new K().addSystemMessage(`\nYou are a helpful expert in writing JavaScript.  A user is asking you for help\nwriting some JavaScript for their application.\n\nYour reply MUST only contain JavaScript code. No explanations,\nno markdown, no delimiters around it. It is crucial for it to only\nbe the code itself.\n\nThe JavaScript you write is going to be run in a sandboxed environment. It\nonly has access to the things I describe to you in this description. It does\nnot have access to things like \\`fetch\\` and \\`window\\`. It also does not have\naccess to the global scope. You can only use the variables and functions I\ndescribe to you.\n\nThe code you are to return is a JavaScript function, except without\nthe function signature, opening brace, and closing brace. Just the\ncontent of the function. The wrapper around the function is\ngenerated elsewhere. Your code _must_ complete with a \\`return\\` statement.\nIt is incorrect for there to be no returns, or for the return to be\nmissing a value.\n\nIf you receive a request that is not to generate code, is abusive, is\ninappropriate, is vague, is ambiguous, or is otherwise not useful, you should\nrespond with an empty string. Nothing else, just a completely blank response.\nYour code is to write code and you should not attempt to do anything else.\n\nThe JavaScript code you're going to write has access to some special global\nvariables and functions that are not standard to JavaScript. These are:\n\n- \\`$\\`: This function allows you to access a context object. The contents of\n  this object will be described later. It takes a string and can return data\n  of any primitive JS type. You are to infer the type and meaning of the data\n  from the string you pass to it. An example of how to call this function would\n  be \\`$(\"Current User.firstName\")\\`. There are no other properties on \\`$\\`,\n  do not try to access them.\n- \\`snippets\\`: An object that contains references to many user-defined utility\n  functions. A full list will be provided later. If a solution is possible\n  using the provided snippets, you should use them. All calls to snippet\n  functions look like \\`snippets.myFunctionName(args)\\`.\n\nWhat follows are some example responses, indented 2 spaces, with an explanation\nbeneath each of whether it's right or wrong.\n\n  console.log(\"Hello, world!\")\n\nThis is incorrect but only because there is no return statement. All code you\nproduce must return a value.\n\n  const foo = \"bar\"\n  return foo\n\nThis is correct.\n\n  const length = $(\"Current User.firstName\").length\n  return length\n\nThis is correct, and correctly uses a binding.\n\n  const name = $.get(\"Current User.firstName\")\n  return name\n\nThis is incorrect, $.get is not a function.\n\n  return window.location.href;\n\nThis is incorrect, window is not available in our sandbox.\n\n  function main() {\n    return 4;\n  }\n  main();\n\nThis is incorrect, nothing is returned. It's fine to define functions but the\ncode you produce must return a value.\n\n  return someVar.length;\n\nThis is incorrect because it references a variable that is not defined. When you\nare asked to do something with some value, that value will be provided to you\nas a binding.\n\n  return snippets.processForAccount(amount);\n\nThis is incorrect because it references an undefined variable \"amount\". It is\nimportant that you never reference a variable that is not defined. If you need\na variable, it will be provided to you as a binding.\n\n${a}\n\n${r}`);\n    }",
    "generateSQL": "function PG(e, t) {\n      return new K().addUserMessage(`Given the table schema:\n${t}\n\nGenerate a SQL query for the following request:\n${e}.\n Only provide the SQL.`);\n    }",
    "generateTables": "function wu() {\n      let e = `\nYou are generating Budibase table schemas from user prompts.\nAlways return at least 2 tables, and define only one side of relationships using a link field.\nExclude id, created_at, and updated_at (Budibase adds them).\nInclude a variety of column types: text, dropdown, date, number.\nAdd at least one formula column, one attachment, and one multi-attachment column across the tables.\nBudibase handles reverse relationships and many-to-many links \\u2014 never define join tables or reverse fields.\nYou may specify foreignColumnName, but do not create that field manually.\n`;\n      return new K().addSystemMessage(e);\n    }",
    "generationStructure": {
      "spa": "function () { [native code] }",
      "_def": {
        "shape": "() => shape",
        "unknownKeys": "strip",
        "catchall": {
          "spa": "function () { [native code] }",
          "_def": {
            "typeName": "ZodNever"
          },
          "parse": "function () { [native code] }",
          "safeParse": "function () { [native code] }",
          "parseAsync": "function () { [native code] }",
          "safeParseAsync": "function () { [native code] }",
          "refine": "function () { [native code] }",
          "refinement": "function () { [native code] }",
          "superRefine": "function () { [native code] }",
          "optional": "function () { [native code] }",
          "nullable": "function () { [native code] }",
          "nullish": "function () { [native code] }",
          "array": "function () { [native code] }",
          "promise": "function () { [native code] }",
          "or": "function () { [native code] }",
          "and": "function () { [native code] }",
          "transform": "function () { [native code] }",
          "brand": "function () { [native code] }",
          "default": "function () { [native code] }",
          "catch": "function () { [native code] }",
          "describe": "function () { [native code] }",
          "pipe": "function () { [native code] }",
          "readonly": "function () { [native code] }",
          "isNullable": "function () { [native code] }",
          "isOptional": "function () { [native code] }",
          "~standard": {
            "version": 1,
            "vendor": "zod",
            "validate": "(data) => this[\"~validate\"](data)"
          }
        },
        "typeName": "ZodObject"
      },
      "parse": "function () { [native code] }",
      "safeParse": "function () { [native code] }",
      "parseAsync": "function () { [native code] }",
      "safeParseAsync": "function () { [native code] }",
      "refine": "function () { [native code] }",
      "refinement": "function () { [native code] }",
      "superRefine": "function () { [native code] }",
      "optional": "function () { [native code] }",
      "nullable": "function () { [native code] }",
      "nullish": "function () { [native code] }",
      "array": "function () { [native code] }",
      "promise": "function () { [native code] }",
      "or": "function () { [native code] }",
      "and": "function () { [native code] }",
      "transform": "function () { [native code] }",
      "brand": "function () { [native code] }",
      "default": "function () { [native code] }",
      "catch": "function () { [native code] }",
      "describe": "function () { [native code] }",
      "pipe": "function () { [native code] }",
      "readonly": "function () { [native code] }",
      "isNullable": "function () { [native code] }",
      "isOptional": "function () { [native code] }",
      "~standard": {
        "version": 1,
        "vendor": "zod",
        "validate": "(data) => this[\"~validate\"](data)"
      },
      "_cached": null,
      "nonstrict": "passthrough() {\n        return new _ZodObject({\n          ...this._def,\n          unknownKeys: \"passthrough\"\n        });\n      }",
      "augment": "extend(augmentation) {\n        return new _ZodObject({\n          ...this._def,\n          shape: () => ({\n            ...this._def.shape(),\n            ...augmentation\n          })\n        });\n      }"
    },
    "getLLM": "async function Pa(e) {\n      return await Ca.tracer.trace(\"getLLM\", async (t) => {\n        let { model: r, maxTokens: a } = e || {}, n = await Su();\n        if (!n) {\n          t.addTags({ enabled: false, reason: \"no config found\" });\n          return;\n        }\n        r && (n.model = r), a && (n.maxTokens = a);\n        let o = _G[n.provider];\n        if (!o) {\n          t.addTags({ enabled: false, reason: \"no provider found\", provider: n.provider });\n          return;\n        }\n        return new o(n);\n      });\n    }",
    "getLLMConfig": "async function Su() {\n      return Ca.tracer.trace(\"getLLMConfig\", async () => await xG() || await OG());\n    }",
    "getLLMOrThrow": "async function yI() {\n      let e = await Pa();\n      if (!e)\n        throw new Xe.HTTPError(\"No available LLM configurations\", 500);\n      return e;\n    }",
    "normalizeContentType": "function pu(e) {\n      return e ? e.includes(\"/\") ? e : { [La.SupportedFileType.PDF]: \"application/pdf\", [La.SupportedFileType.JPG]: \"image/jpeg\", [La.SupportedFileType.JPEG]: \"image/jpeg\", [La.SupportedFileType.PNG]: \"image/png\" }[e.toLowerCase()] || \"application/octet-stream\" : \"application/octet-stream\";\n    }",
    "parseResponseFormat": "function eo(e) {\n      if (e)\n        return e === \"text\" ? { type: \"text\" } : e === \"json\" ? { type: \"json_object\" } : e;\n    }",
    "sanitiseToolName": "function EG(e) {\n      if (e.length > 64)\n        throw new Error(\"Tool name must be under 64 characters long\");\n      return e.replace(/[^a-zA-Z0-9_-]/g, \"_\");\n    }",
    "searchWeb": "function yu(e) {\n      return new K().addUserMessage(`Search the web for the following: \"${e}\". Only return the top results.`);\n    }",
    "sentimentAnalysis": "function gu(e) {\n      return new K().addUserMessage(`Return the sentiment of this text: \"${e}\". Only return the sentiment.`);\n    }",
    "summarizeText": "function Zn(e, t) {\n      let r = `Summarize this text:\n${e}`, a = \"\";\n      if (t)\n        switch (t) {\n          case oo.SummariseLength.SHORT:\n            a = \"In 1-2 concise sentences, \";\n            break;\n          case oo.SummariseLength.MEDIUM:\n            a = \"In 2-3 paragraphs, \";\n            break;\n          case oo.SummariseLength.LONG:\n            a = \"In multiple detailed paragraphs, \";\n            break;\n        }\n      return new K().addUserMessage(`${a}${r}. \nOnly return the summary.`);\n    }",
    "tableDataStructuredOutput": "function Lu(e) {\n      let t = k.z.object({});\n      for (let r of e) {\n        let a = { _id: k.z.string().describe(\"Unique ID for the row\") }, n = k.z.union([k.z.literal(\"https://picsum.photos/600/600\").describe(\"For profile pictures and similar\"), k.z.literal(\"https://picsum.photos/1920/1080\").describe(\"For anything else\")]), o = k.z.object({ fileName: k.z.string(), extension: k.z.enum([\".pdf\", \".txt\"]), content: k.z.string().describe(\"Random content for the file\") });\n        for (let s of Object.values(r.schema)) {\n          let { type: i } = s;\n          switch (i) {\n            case D.FieldType.STRING:\n            case D.FieldType.LONGFORM:\n              a[s.name] = k.z.string();\n              break;\n            case D.FieldType.NUMBER:\n            case D.FieldType.BIGINT:\n              a[s.name] = k.z.number();\n              break;\n            case D.FieldType.BOOLEAN:\n              a[s.name] = k.z.boolean();\n              break;\n            case D.FieldType.DATETIME:\n              a[s.name] = k.z.string().describe(`ISO datetime. Use realistic dates, based on today's date, ${(/* @__PURE__ */ new Date()).toISOString()}`);\n              break;\n            case D.FieldType.ATTACHMENT_SINGLE:\n              s.subtype === D.AttachmentSubType.IMAGE ? a[s.name] = n : a[s.name] = o;\n              break;\n            case D.FieldType.ATTACHMENTS:\n              s.subtype === D.AttachmentSubType.IMAGE ? a[s.name] = k.z.array(n) : a[s.name] = k.z.array(o), a[s.name] = a[s.name].describe(\"Between 2 and 5 items.\");\n              break;\n            case D.FieldType.OPTIONS:\n              a[s.name] = k.z.enum(s.constraints.inclusion);\n              break;\n            case D.FieldType.LINK:\n              {\n                let p = k.z.string().describe(`Match one of the _ids created for table \"${s.tableId}\"`);\n                s.relationshipType === D.RelationshipType.ONE_TO_MANY ? a[s.name] = k.z.array(p).describe(\"Array with a single item\") : s.relationshipType === D.RelationshipType.MANY_TO_MANY && (a[s.name] = k.z.array(p).describe(\"Array with a one or many items. You can repeat the same ids between rows\"));\n              }\n              break;\n            case D.FieldType.ARRAY:\n              a[s.name] = k.z.array(k.z.enum(s.constraints.inclusion));\n              break;\n            case D.FieldType.AI:\n            case D.FieldType.AUTO:\n            case D.FieldType.SIGNATURE_SINGLE:\n            case D.FieldType.BB_REFERENCE:\n            case D.FieldType.JSON:\n            case D.FieldType.FORMULA:\n            case D.FieldType.INTERNAL:\n            case D.FieldType.BARCODEQR:\n            case D.FieldType.BB_REFERENCE_SINGLE:\n              break;\n            default:\n              throw AI.utils.unreachable(i);\n          }\n        }\n        t = t.extend({ [r.name]: k.z.array(k.z.object(a)) }).describe(`Each table should include at least a few items (min 3, max 18). The number of items should not be evenly distributed. Instead, follow natural relationships and usage patterns based on the tables nature. For example:\n                1. If we have posts and comments, there should be more posts than users, and more comments than posts.\n                2. If it's a ticketing system, there may be more tickets than users, and some users may have submitted several tickets.\n                3. In a CRM, there are fewer users than customers, and customers may have many deals.\n                4. In a project management tool, projects might have many tasks, and tasks might have multiple comments.`);\n      }\n      return t;\n    }",
    "translate": "function mu(e, t) {\n      return new K().addUserMessage(`Translate the following text: \"${e}\" into ${t}. Only return the translation.`);\n    }"
  },
  "api": {
    "appBackups": {
      "opts": {},
      "methods": [
        "HEAD",
        "OPTIONS",
        "GET",
        "PUT",
        "PATCH",
        "POST",
        "DELETE"
      ],
      "exclusive": false,
      "params": {},
      "stack": [
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [
            {
              "name": "appId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/apps/:appId/backups",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [
            {
              "name": "appId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/apps/:appId/backups/search",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [
            {
              "name": "appId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            },
            {
              "name": "backupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/apps/:appId/backups/:backupId/file",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "PATCH"
          ],
          "paramNames": [
            {
              "name": "appId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            },
            {
              "name": "backupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/apps/:appId/backups/:backupId",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "DELETE"
          ],
          "paramNames": [
            {
              "name": "appId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            },
            {
              "name": "backupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/apps/:appId/backups/:backupId",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [
            {
              "name": "appId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            },
            {
              "name": "backupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/apps/:appId/backups/:backupId/import",
          "regexp": {}
        }
      ]
    },
    "auditLogs": {
      "opts": {},
      "methods": [
        "HEAD",
        "OPTIONS",
        "GET",
        "PUT",
        "PATCH",
        "POST",
        "DELETE"
      ],
      "exclusive": false,
      "params": {},
      "stack": [
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/auditlogs/search",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/auditlogs/download",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/auditlogs/definitions",
          "regexp": {}
        }
      ]
    },
    "environmentVariables": {
      "opts": {},
      "methods": [
        "HEAD",
        "OPTIONS",
        "GET",
        "PUT",
        "PATCH",
        "POST",
        "DELETE"
      ],
      "exclusive": false,
      "params": {},
      "stack": [
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/env/variables/status",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/env/variables",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/env/variables",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "PATCH"
          ],
          "paramNames": [
            {
              "name": "varName",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/env/variables/:varName",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "DELETE"
          ],
          "paramNames": [
            {
              "name": "varName",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/env/variables/:varName",
          "regexp": {}
        }
      ]
    },
    "groups": {
      "opts": {},
      "methods": [
        "HEAD",
        "OPTIONS",
        "GET",
        "PUT",
        "PATCH",
        "POST",
        "DELETE"
      ],
      "exclusive": false,
      "params": {},
      "stack": [
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/groups",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/groups",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "DELETE"
          ],
          "paramNames": [
            {
              "name": "groupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            },
            {
              "name": "rev",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/groups/:groupId/:rev",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [
            {
              "name": "groupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/groups/:groupId",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [
            {
              "name": "groupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/groups/:groupId/users",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [
            {
              "name": "groupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/groups/:groupId/users",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [
            {
              "name": "groupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/groups/:groupId/apps",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [
            {
              "name": "groupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            },
            {
              "name": "appId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/groups/:groupId/app/:appId/builder",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "DELETE"
          ],
          "paramNames": [
            {
              "name": "groupId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            },
            {
              "name": "appId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/groups/:groupId/app/:appId/builder",
          "regexp": {}
        }
      ]
    },
    "scim": {
      "opts": {
        "prefix": "/api/global/scim/v2"
      },
      "methods": [
        "HEAD",
        "OPTIONS",
        "GET",
        "PUT",
        "PATCH",
        "POST",
        "DELETE"
      ],
      "exclusive": false,
      "params": {},
      "stack": [
        {
          "opts": {
            "end": false,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2",
            "ignoreCaptures": true
          },
          "name": null,
          "methods": [],
          "paramNames": [
            {
              "name": 0,
              "prefix": "",
              "suffix": "",
              "pattern": "[^/]*",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2([^/]*)",
          "regexp": {}
        },
        {
          "opts": {
            "end": false,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2",
            "ignoreCaptures": true
          },
          "name": null,
          "methods": [],
          "paramNames": [
            {
              "name": 0,
              "prefix": "",
              "suffix": "",
              "pattern": "[^/]*",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2([^/]*)",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2"
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2/users",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2"
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [
            {
              "name": "id",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2/users/:id",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2"
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2/users",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2"
          },
          "name": null,
          "methods": [
            "PATCH"
          ],
          "paramNames": [
            {
              "name": "id",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2/users/:id",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2"
          },
          "name": null,
          "methods": [
            "DELETE"
          ],
          "paramNames": [
            {
              "name": "id",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2/users/:id",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2"
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2/groups",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2"
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2/groups",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2"
          },
          "name": null,
          "methods": [
            "HEAD",
            "GET"
          ],
          "paramNames": [
            {
              "name": "id",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2/groups/:id",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2"
          },
          "name": null,
          "methods": [
            "DELETE"
          ],
          "paramNames": [
            {
              "name": "id",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2/groups/:id",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": "/api/global/scim/v2"
          },
          "name": null,
          "methods": [
            "PATCH"
          ],
          "paramNames": [
            {
              "name": "id",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/scim/v2/groups/:id",
          "regexp": {}
        }
      ]
    },
    "users": {
      "opts": {},
      "methods": [
        "HEAD",
        "OPTIONS",
        "GET",
        "PUT",
        "PATCH",
        "POST",
        "DELETE"
      ],
      "exclusive": false,
      "params": {},
      "stack": [
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "POST"
          ],
          "paramNames": [
            {
              "name": "userId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            },
            {
              "name": "appId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/users/:userId/app/:appId/builder",
          "regexp": {}
        },
        {
          "opts": {
            "end": true,
            "name": null,
            "sensitive": false,
            "strict": false,
            "prefix": ""
          },
          "name": null,
          "methods": [
            "DELETE"
          ],
          "paramNames": [
            {
              "name": "userId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            },
            {
              "name": "appId",
              "prefix": "/",
              "suffix": "",
              "pattern": "[^\\/#\\?]+?",
              "modifier": ""
            }
          ],
          "stack": [
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }",
            "function (ctx, next) {\n    if (!ctx || !enterChannel.hasSubscribers) return fn.apply(this, arguments)\n\n    const req = ctx.req\n\n    const path = layer && layer.path\n    const route = typeof path === 'string' && !path.endsWith('(.*)') && !path.endsWith('([^/]*)') && path\n\n    enterChannel.publish({ req, name, route })\n\n    if (typeof next === 'function') {\n      arguments[1] = wrapNext(req, next)\n    }\n\n    try {\n      const result = fn.apply(this, arguments)\n\n      if (result && typeof result.then === 'function') {\n        return result.then(\n          result => {\n            fulfill(ctx)\n            return result\n          },\n          err => {\n            fulfill(ctx, err)\n            throw err\n          }\n        )\n      }\n      fulfill(ctx)\n      return result\n    } catch (e) {\n      fulfill(ctx, e)\n      throw e\n    } finally {\n      exitChannel.publish({ req })\n    }\n  }"
          ],
          "path": "/api/global/users/:userId/app/:appId/builder",
          "regexp": {}
        }
      ]
    }
  },
  "auditLogs": {
    "definitions": "function AO() {\n      let e = Object.entries(Ln.AuditedEventFriendlyName).filter((r) => r[1] != null), t = {};\n      for (let r of e)\n        t[r[0]] = Fs(r[1]);\n      return t;\n    }",
    "download": "function hO(e) {\n      return e = Gs(e), Xf(e);\n    }",
    "fetch": "async function yO(e) {\n      if (!await hn())\n        throw new Error(\"Audit logs not available - license required.\");\n      let t = await Zf(e);\n      if (typeof e.bookmark == \"string\")\n        throw new Error(\"String based bookmark not supported.\");\n      let r = await Ms(t, e.bookmark);\n      return { hasNextPage: r.hasNextPage, bookmark: r.bookmark, data: await gO(r.rows) };\n    }",
    "write": "async function mO(e, t, r) {\n      if (!await hn() || !le.utils.isAudited(e))\n        return;\n      let a = em(e, t), n = /* @__PURE__ */ new Date();\n      r?.timestamp && (n = new Date(r.timestamp));\n      let o = { timestamp: n.toISOString(), event: e, name: a, userId: r?.userId || Ln.AuditLogSystemUser, metadata: { ...t, ...r?.hostInfo } }, s = {};\n      try {\n        if (r?.appId) {\n          o.appId = le.db.getProdAppID(r.appId);\n          let i = await le.cache.app.getAppMetadata(r.appId);\n          \"name\" in i && (s.appName = i.name);\n        }\n        if (r?.userId) {\n          let i = await le.users.getById(r?.userId);\n          s.email = i.email;\n        }\n      } catch (i) {\n        le.logging.logAlert(\"Failed to retrieve fallback information for audit log\", i);\n      }\n      return o.fallback = s, await Jf(o);\n    }"
  },
  "automations": {
    "logs": {
      "logSearch": "async function Xx(e) {\n      return await Ns(), await Jx(e.startDate, e.status, e.automationId, e.page);\n    }",
      "oldestLogDate": "async () => $a(En.ConstantQuotaName.AUTOMATION_LOG_RETENTION_DAYS)",
      "storeLog": "async function Zx(e, t) {\n      if (!Rn.db.isProdAppID(Rn.context.getAppId()))\n        return;\n      let r = await Gf(e, t);\n      t.status === kf.AutomationStatus.ERROR && await Ds([r]), await Ns();\n    }"
    }
  },
  "backups": {
    "isEnabled": "async function fs() {\n      return ie(se.Feature.APP_BACKUPS);\n    }",
    "triggerAppRestore": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "triggerAppBackup": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "getBackupDownloadStream": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "downloadAppBackup": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "fetchAppBackups": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "storeAppBackupMetadata": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "updateBackupStatus": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "updateRestoreStatus": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "getAppBackup": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "updateAppBackup": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "deleteAppBackup": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
    "processing": {
      "init": "async function Hs(e) {\n      qt().process(async (t) => {\n        let r = t.data;\n        try {\n          if (r.export)\n            return console.log(\"Exporting app backup:\", r.appId, r.export.trigger), NO(t, e);\n          if (r.import)\n            return console.log(\"Importing app backup:\", r.appId, r.import.backupId), DO(t, e);\n        } catch (a) {\n          W.logging.logAlert(`Failed to perform backup for app ID: ${r.appId}`, a);\n        }\n      });\n    }"
    },
    "init": "async (e) => {\n      rm(), await Hs(e.processing);\n    }",
    "getBackupQueue": "function qt() {\n      return tm;\n    }"
  },
  "branding": {
    "getBrandingConfig": "async function vx(e) {\n      return await ms() ? { faviconUrl: e.faviconUrl, faviconUrlEtag: e.faviconUrlEtag, emailBrandingEnabled: e.emailBrandingEnabled, testimonialsEnabled: e.testimonialsEnabled, platformTitle: e.platformTitle, loginHeading: e.loginHeading, loginButton: e.loginButton, metaDescription: e.metaDescription, metaImageUrl: e.metaImageUrl, metaTitle: e.metaTitle } : Tx;\n    }"
  },
  "constants": {
    "GENERIC_PAGE_SIZE": 9,
    "auditLogs": {
      "searchTable": "function pS() {\n      return { type: \"table\", sourceType: Et.TableSourceType.INTERNAL, name: Et.AUDIT_LOG_TYPE, sourceId: dp.SQS_DATASOURCE_INTERNAL, primary: [\"_id\"], schema: { metadata: { name: \"metadata\", type: Et.FieldType.JSON }, fallback: { name: \"fallback\", type: Et.FieldType.JSON } } };\n    }"
    },
    "licenses": {
      "CLOUD_FREE_LICENSE": {
        "features": [],
        "quotas": {
          "usage": {
            "monthly": {
              "queries": {
                "name": "Queries",
                "value": -1,
                "triggers": []
              },
              "automations": {
                "name": "Automations",
                "value": 200,
                "triggers": [
                  80,
                  90,
                  100
                ]
              },
              "budibaseAICredits": {
                "name": "Budibase AI Credits",
                "value": 50000,
                "triggers": [
                  80,
                  90,
                  100
                ]
              },
              "actions": {
                "name": "Actions",
                "value": -1,
                "triggers": [
                  80,
                  90,
                  100
                ]
              }
            },
            "static": {
              "apps": {
                "name": "Apps",
                "value": -1,
                "triggers": [
                  100
                ]
              },
              "rows": {
                "name": "Rows",
                "value": 2000,
                "triggers": [
                  90,
                  100
                ]
              },
              "users": {
                "name": "Users",
                "value": 5,
                "triggers": [
                  80,
                  100
                ]
              },
              "creators": {
                "name": "Creators",
                "value": 5,
                "triggers": []
              },
              "userGroups": {
                "name": "User Groups",
                "value": 0,
                "triggers": [
                  80,
                  100
                ]
              },
              "plugins": {
                "name": "Plugins",
                "value": 10,
                "triggers": [
                  90,
                  100
                ]
              },
              "aiCustomConfigs": {
                "name": "Custom AI Configuration",
                "value": 0,
                "triggers": []
              }
            }
          },
          "constant": {
            "automationLogRetentionDays": {
              "name": "Automation Logs",
              "value": 1,
              "triggers": []
            },
            "appBackupRetentionDays": {
              "name": "App Backups",
              "value": 0,
              "triggers": []
            }
          }
        },
        "plan": {
          "type": "free",
          "usesInvoicing": false,
          "model": "perUser"
        }
      },
      "SELF_FREE_LICENSE": {
        "features": [],
        "quotas": {
          "usage": {
            "monthly": {
              "queries": {
                "name": "Queries",
                "value": -1,
                "triggers": []
              },
              "automations": {
                "name": "Automations",
                "value": -1,
                "triggers": [
                  80,
                  90,
                  100
                ]
              },
              "budibaseAICredits": {
                "name": "Budibase AI Credits",
                "value": 50000,
                "triggers": [
                  80,
                  90,
                  100
                ]
              },
              "actions": {
                "name": "Actions",
                "value": -1,
                "triggers": [
                  80,
                  90,
                  100
                ]
              }
            },
            "static": {
              "rows": {
                "name": "Rows",
                "value": -1,
                "triggers": [
                  90,
                  100
                ]
              },
              "apps": {
                "name": "Apps",
                "value": -1,
                "triggers": [
                  100
                ]
              },
              "users": {
                "name": "Users",
                "value": 20,
                "triggers": [
                  80,
                  100
                ]
              },
              "creators": {
                "name": "Creators",
                "value": -1,
                "triggers": []
              },
              "userGroups": {
                "name": "User Groups",
                "value": 0,
                "triggers": [
                  80,
                  100
                ]
              },
              "plugins": {
                "name": "Plugins",
                "value": 10,
                "triggers": [
                  90,
                  100
                ]
              },
              "aiCustomConfigs": {
                "name": "Custom AI Configuration",
                "value": 0,
                "triggers": []
              }
            }
          },
          "constant": {
            "automationLogRetentionDays": {
              "name": "Automation Logs",
              "value": 1,
              "triggers": []
            },
            "appBackupRetentionDays": {
              "name": "App Backups",
              "value": 0,
              "triggers": []
            }
          }
        },
        "plan": {
          "type": "free",
          "usesInvoicing": false,
          "model": "perUser"
        }
      },
      "UNLIMITED": -1,
      "UNLIMITED_LICENSE": {
        "features": [],
        "quotas": {
          "usage": {
            "monthly": {
              "queries": {
                "name": "Queries",
                "value": -1,
                "triggers": []
              },
              "automations": {
                "name": "Automations",
                "value": -1,
                "triggers": [
                  80,
                  90,
                  100
                ]
              },
              "budibaseAICredits": {
                "name": "Budibase AI Credits",
                "value": -1,
                "triggers": [
                  80,
                  90,
                  100
                ]
              },
              "actions": {
                "name": "Actions",
                "value": -1,
                "triggers": [
                  80,
                  90,
                  100
                ]
              }
            },
            "static": {
              "apps": {
                "name": "Apps",
                "value": -1,
                "triggers": [
                  100
                ]
              },
              "rows": {
                "name": "Rows",
                "value": -1,
                "triggers": [
                  90,
                  100
                ]
              },
              "users": {
                "name": "Users",
                "value": -1,
                "triggers": [
                  80,
                  100
                ]
              },
              "creators": {
                "name": "Creators",
                "value": -1,
                "triggers": []
              },
              "userGroups": {
                "name": "User Groups",
                "value": -1,
                "triggers": [
                  80,
                  100
                ]
              },
              "plugins": {
                "name": "Plugins",
                "value": -1,
                "triggers": [
                  90,
                  100
                ]
              },
              "aiCustomConfigs": {
                "name": "Custom AI Configuration",
                "value": -1,
                "triggers": []
              }
            }
          },
          "constant": {
            "automationLogRetentionDays": {
              "name": "Automation Logs",
              "value": -1,
              "triggers": []
            },
            "appBackupRetentionDays": {
              "name": "App Backups",
              "value": -1,
              "triggers": []
            }
          }
        },
        "plan": {
          "type": "free",
          "usesInvoicing": false,
          "model": "perUser"
        }
      }
    },
    "quotas": {
      "UNLIMITED": -1,
      "actions": "(e) => ({ [te.MonthlyQuotaName.ACTIONS]: { name: \"Actions\", value: e, triggers: [80, 90, 100] } })",
      "appBackupRetentionDays": "(e) => ({ [te.ConstantQuotaName.APP_BACKUPS_RETENTION_DAYS]: { name: \"App Backups\", value: e, triggers: [] } })",
      "apps": "(e) => ({ [te.StaticQuotaName.APPS]: { name: \"Apps\", value: e, triggers: [100] } })",
      "automationLogRetentionDays": "(e) => ({ [te.ConstantQuotaName.AUTOMATION_LOG_RETENTION_DAYS]: { name: \"Automation Logs\", value: e, triggers: [] } })",
      "automations": "(e) => ({ [te.MonthlyQuotaName.AUTOMATIONS]: { name: \"Automations\", value: e, triggers: [80, 90, 100] } })",
      "budibaseAICredits": "(e) => ({ [te.MonthlyQuotaName.BUDIBASE_AI_CREDITS]: { name: \"Budibase AI Credits\", value: e, triggers: [80, 90, 100] } })",
      "creators": "(e) => ({ [te.StaticQuotaName.CREATORS]: { name: \"Creators\", value: e, triggers: [] } })",
      "customAIConfigurations": "(e) => ({ [te.StaticQuotaName.AI_CUSTOM_CONFIGS]: { name: \"Custom AI Configuration\", value: e, triggers: [] } })",
      "plugins": "(e) => ({ [te.StaticQuotaName.PLUGINS]: { name: \"Plugins\", value: e, triggers: [90, 100] } })",
      "queries": "(e) => ({ [te.MonthlyQuotaName.QUERIES]: { name: \"Queries\", value: e, triggers: [] } })",
      "rows": "(e) => ({ [te.StaticQuotaName.ROWS]: { name: \"Rows\", value: e, triggers: [90, 100] } })",
      "userGroups": "(e) => ({ [te.StaticQuotaName.USER_GROUPS]: { name: \"User Groups\", value: e, triggers: [80, 100] } })",
      "users": "(e) => ({ [te.StaticQuotaName.USERS]: { name: \"Users\", value: e, triggers: [80, 100] } })"
    },
    "versions": {
      "getLicenseVersion": "() => {\n      if (vt.env.isDev()) {\n        let e = \"dev-version.txt\", t = cp.default.join(vt.objectStore.budibaseTempDir(), e);\n        if (Wa.default.existsSync(t))\n          return Wa.default.readFileSync(t, \"utf8\");\n        {\n          let r = vt.utils.newid();\n          return Wa.default.writeFileSync(t, r), r;\n        }\n      } else\n        return lp();\n    }",
      "getProVersion": "() => {\n      let e = vt.env.VERSION;\n      if (!e)\n        throw new Error(\"No budibase pro version was specified\");\n      return e;\n    }"
    }
  },
  "environmentVariables": {
    "fetch": "async function nO() {\n      let e = await Rt.get();\n      return Object.keys(e.variables);\n    }",
    "fetchValues": "async function oO(e) {\n      let r = (await Rt.get()).variables, a = {};\n      for (let [n, o] of Object.entries(r))\n        switch (e) {\n          case ba.AppEnvironment.DEVELOPMENT:\n            a[n] = o.development;\n            break;\n          case ba.AppEnvironment.PRODUCTION:\n          default:\n            a[n] = o.production;\n            break;\n        }\n      return a;\n    }",
    "isEncryptionKeyAvailable": "function aO() {\n      return !!Kf.env.ENCRYPTION_KEY;\n    }",
    "isValid": "function Yf(e) {\n      return /^[a-zA-Z0-9-_]+$/.test(e);\n    }",
    "remove": "async function iO(e) {\n      await Vf((t) => (delete t[e], t));\n    }",
    "update": "async function sO(e, t) {\n      if (Yf(e))\n        await Vf((a) => (a[e] = t, a));\n      else\n        throw new Error(\"Variable name has characters that are not allowed\");\n    }"
  },
  "features": {
    "checkBackups": "function he(e) {\n      return async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t));\n    }",
    "checkFeature": "async function yn(e, t) {\n      if (!await ie(e, t))\n        throw new et.FeatureDisabledError(`${e} is not currently enabled`, e);\n    }",
    "checkFeatures": "async function ds(e, t) {\n      if (!await ie(e, t)) {\n        let r = e.join(\", \");\n        throw new et.FeatureDisabledError(`${r} are not currently enabled`, r);\n      }\n    }",
    "checkSCIM": "async () => {\n      let e = se.Feature.SCIM, t = await ie(e), r = await et.configs.getSCIMConfig();\n      if (!t || !r?.enabled)\n        throw new et.FeatureDisabledError(`${e} is not currently enabled`, e);\n      return true;\n    }",
    "isAppBuildersEnabled": "async function Ct() {\n      return ie(se.Feature.APP_BUILDERS);\n    }",
    "isAuditLogsEnabled": "async function hn() {\n      return ie(se.Feature.AUDIT_LOGS);\n    }",
    "isBackupsEnabled": "async function fs() {\n      return ie(se.Feature.APP_BACKUPS);\n    }",
    "isBrandingEnabled": "async function ms() {\n      return ie(se.Feature.BRANDING);\n    }",
    "isEnforceableSSO": "async function wf() {\n      return ie(se.Feature.ENFORCEABLE_SSO);\n    }",
    "isExpandedPublicApiEnabled": "async function tt() {\n      return ie(se.Feature.EXPANDED_PUBLIC_API);\n    }",
    "isPWAEnabled": "function bx() {\n      return ie(se.Feature.PWA);\n    }",
    "isSSOEnforced": "async function Ix(e) {\n      if (et.env.ENABLE_SSO_MAINTENANCE_MODE || !await wf())\n        return false;\n      let r;\n      return e?.config ? r = e.config : r = await et.configs.getSettingsConfig(), !!r.isSSOEnforced;\n    }",
    "isSyncAutomationsEnabled": "async function hx() {\n      return ie(se.Feature.SYNC_AUTOMATIONS);\n    }",
    "isTriggerAutomationRunEnabled": "async function Ax() {\n      return ie(se.Feature.TRIGGER_AUTOMATION_RUN);\n    }",
    "isUserGroupsEnabled": "async function gs() {\n      return ie(se.Feature.USER_GROUPS);\n    }",
    "isViewPermissionEnabled": "async function Sx() {\n      return ie(se.Feature.VIEW_PERMISSIONS);\n    }",
    "isViewReadonlyColumnsEnabled": "async function wx() {\n      return ie(se.Feature.VIEW_READONLY_COLUMNS);\n    }"
  },
  "groups": {
    "addAppBuilder": "async function Os(e, t) {\n      if (!await Ct())\n        throw new Error(\"Feature not enabled, please check license\");\n      let r = x.db.getProdAppID(t), a = await Ut(e);\n      a.builder ??= { apps: [] }, a.builder.apps.includes(t) || (a.builder.apps.push(r), await lr(a));\n    }",
    "addUsers": "async function Rs(e, t) {\n      let r = await M.get(e), a = await x.users.bulkGetGlobalUsersById(t), n = [];\n      for (let p of a)\n        p.userGroups || (p.userGroups = []), p.userGroups.includes(e) || n.push(p);\n      if (!n.length)\n        return n;\n      let o = n.map((p) => ({ ...p, userGroups: [...p?.userGroups || [], e] }));\n      if (await x.users.bulkUpdateGlobalUsers(o), Object.values(r.roles || {}).includes(\"CREATOR\")) {\n        let f = (await x.userUtils.creatorsInList(n)).filter((y) => y).length, m = n.length - f;\n        m && await Sn(0, m);\n      }\n      let i = [];\n      for (let p of t)\n        i.push(x.cache.user.invalidateUser(p));\n      return await Promise.all(i), await x.events.group.usersAdded(o.length, r), o;\n    }",
    "adjustGroupCreatorsQuotas": "async function Fx() {\n      if (!await gs()) {\n        let e = x.tenancy.getGlobalDB(), r = (await ha() || []).filter((a) => Object.values(a?.roles || {}).includes(\"CREATOR\"));\n        for (let a of r) {\n          let n = await M.getGroupUsers(a._id), s = (await Promise.all(n.map((m) => e.get(m._id)))).map((m) => ({ ...m, userGroups: m.userGroups.filter((y) => y !== a._id) })), p = (await x.userUtils.creatorsInList(s)).filter((m) => m).length, f = n.length - p;\n          await M.save({ ...a, roles: {} }), f && await cr(0, f);\n        }\n      }\n    }",
    "cleanupApp": "async function kx(e) {\n      let t = await ha(), r = [];\n      for (let a of t)\n        !a.roles || !a.roles[e] || (delete a.roles[e], r.push(a));\n      return await M.bulkSave(r);\n    }",
    "enrichUserRolesFromGroups": "async function Gx(e) {\n      if (!e || !e.userGroups)\n        return e;\n      let t = await qf(e.userGroups, { enriched: false }), r = [];\n      for (let n of t)\n        n?.roles && (r = r.concat(Object.keys(n.roles)));\n      r = [...new Set(r)];\n      for (let n of r)\n        await x.context.doInAppContext(n, async () => {\n          if (e.roles[n])\n            return;\n          let o = await Cf(t, n);\n          o && (e.roles[n] = o);\n        });\n      let a = await Uf(e, { groups: t });\n      if (a.length && !e.builder?.global) {\n        let n = e.builder?.apps || [];\n        e.builder = { apps: n.concat(a) };\n      }\n      return e;\n    }",
    "fetch": "async function ha() {\n      return await M.fetch();\n    }",
    "get": "async function Ut(e) {\n      return await M.get(e);\n    }",
    "getBulk": "async function qf(e, t = { enriched: true }) {\n      return await M.getBulk(e, t);\n    }",
    "getGroupBuilderAppIds": "async function Uf(e, t) {\n      if (!e.userGroups)\n        return [];\n      let r = await Pf(e.userGroups, t?.groups), a = t?.appId ? x.db.getProdAppID(t?.appId) : null, n = [];\n      for (let o of r) {\n        let s = o.builder?.apps;\n        a && s?.includes(a) ? n.push(a) : a || (n = n.concat(s || []));\n      }\n      return [...new Set(n)];\n    }",
    "getGroupRoleId": "async function Mx(e, t, r) {\n      if (!e.userGroups)\n        return null;\n      let a = await Pf(e.userGroups, r?.groups), n = x.db.getProdAppID(t);\n      return e.roles?.[n] ? e.roles[n] : (a = a.filter((o) => o?.roles ? Object.keys(o.roles).includes(n) : false), await Cf(a, t));\n    }",
    "remove": "async function Es(e, t) {\n      let r;\n      try {\n        r = await M.get(e);\n      } catch {\n        throw new Error(\"Group not found\");\n      }\n      let a = Object.values(r.roles || {}).includes(\"CREATOR\"), n = () => {\n      };\n      if (a) {\n        let s = x.tenancy.getGlobalDB(), i = await M.getGroupUsers(e), f = (await Promise.all(i.map((I) => s.get(I._id)))).map((I) => ({ ...I, userGroups: I.userGroups.filter((L) => L !== e) })), y = (await x.userUtils.creatorsInList(f)).filter((I) => I).length, g = i.length - y;\n        g && (n = () => cr(0, g));\n      }\n      let o = await M.destroy(e, t);\n      return await x.events.group.deleted(r), await Ss(), await n(), o;\n    }",
    "removeAppBuilder": "async function Ls(e, t) {\n      if (!await Ct())\n        throw new Error(\"Feature not enabled, please check license\");\n      let r = x.db.getProdAppID(t), a = await Ut(e);\n      a.builder?.apps.includes(t) && (a.builder.apps = a.builder.apps.filter((n) => n !== r), await lr(a));\n    }",
    "removeUsers": "async function _s(e, t) {\n      let r = await M.get(e), a = await x.users.bulkGetGlobalUsersById(t), n = [];\n      for (let i of a) {\n        if (!i.userGroups || !i.userGroups.includes(e))\n          continue;\n        let p = i.userGroups.indexOf(e);\n        i.userGroups.splice(p, 1), n.push(i);\n      }\n      if (await x.users.bulkUpdateGlobalUsers(n), Object.values(r.roles || {}).includes(\"CREATOR\")) {\n        let p = (await x.userUtils.creatorsInList(n)).filter((m) => m).length, f = n.length - p;\n        f && await cr(0, f);\n      }\n      let s = [];\n      for (let i of t)\n        s.push(x.cache.user.invalidateUser(i));\n      return await Promise.all(s), n.length && await x.events.group.usersDeleted(n.length, r), n;\n    }",
    "save": "async function lr(e) {\n      let t = [], r = !e._id, a = 0;\n      if (delete e.users, !e._id)\n        e._id = M.generateUserGroupID(), await Of(e.name), t.push(x.events.group.created(e));\n      else {\n        let o = await M.get(e._id);\n        if (o.name !== e.name && await Of(e.name), t.push(x.events.group.updated(e)), JSON.stringify(o.roles) !== JSON.stringify(e.roles)) {\n          let s = o.users?.length || 0, i = 0;\n          s > 0 && (i = await Lf(o)), Object.values(e.roles).includes(\"CREATOR\") ? a = s - i : a = -s, t.push(x.events.group.permissionsEdited(e));\n        }\n      }\n      await Promise.all(t);\n      let n = () => M.save(e);\n      if (r)\n        return await Is(n);\n      {\n        let o = await n();\n        if (a > 0)\n          await Sn(0, a);\n        else if (a < 0) {\n          let s = await Lf(e), i = Math.abs(a) - s;\n          i > 0 && await cr(0, i);\n        }\n        return o;\n      }\n    }",
    "updateGroupApps": "async function xs(e, t) {\n      let r = await Ut(e);\n      if (r.roles || (r.roles = {}), t.appsToAdd)\n        for (let a of t.appsToAdd)\n          r.roles[a.appId] = a.roleId;\n      if (t.appsToRemove)\n        for (let a of t.appsToRemove)\n          delete r.roles[a.appId];\n      return await lr(r);\n    }"
  },
  "init": "async (e) => {\n      e.backups && await Re.init(e.backups);\n    }",
  "licensing": {
    "cache": {
      "getCachedLicense": "async (e, t) => {\n      let { populateLicense: r = is, populateFreeLicense: a = ps } = t || {};\n      return await gn.default.trace(\"getCachedLicense\", async (n) => {\n        let o = Lt.context.getLicense();\n        if (o)\n          return n.addTags({ foundInContext: true, features: o.features, plan: o.plan, quotas: o.quotas }), o;\n        let s = Lt.tenancy.getTenantId(), i = await io(), p = await i.get(s);\n        return n.addTags({ tenantId: s, foundInCache: !!p }), p ? (n.addTags({ foundInCache: true, refreshedAt: p.refreshedAt, features: p.features, plan: p.plan, quotas: p.quotas }), p) : (p = await gn.default.trace(\"populateLicense\", async () => await r(s)), n.addTags({ populatedLicense: !!p }), p || (p = gn.default.trace(\"populateFreeLicense\", () => a(e, s)), n.addTags({ populatedFreeLicense: !!p })), p.refreshedAt = (/* @__PURE__ */ new Date()).toISOString(), n.addTags({ refreshedAt: p.refreshedAt, features: p.features, plan: p.plan, quotas: p.quotas, expirySeconds: Af }), await i.store(s, p, Af), p);\n      });\n    }",
      "invalidate": "async () => {\n      let e = Lt.tenancy.getTenantId();\n      await (await io()).delete(e);\n    }",
      "refresh": "async () => {\n      await Sf(), await If();\n    }"
    },
    "client": {
      "activateLicenseKey": "async (e) => {\n      let t = await C.installation.getInstall(), r = { installVersion: t.version, installId: t.installId }, a = await Ya.post(\"/api/license/activate\", { headers: { [C.constants.Header.LICENSE_KEY]: e }, body: r });\n      if (a.status === 403)\n        throw new C.HTTPError(\"Invalid license key\", 400);\n      if (a.status === 409)\n        throw new C.HTTPError(\"License key has already been activated\", 409);\n      if (a.status !== 200) {\n        let n = await Ha(a);\n        throw new C.HTTPError(`Error activating license key: ${n}`, a.status);\n      }\n      return a.json();\n    }",
      "getLicense": "async () => await wo.tracer.trace(\"_getLicense\", async () => await Sp(async (e) => {\n      let t = await ke.getQuotaUsage();\n      if (t.usageQuota.users == null) {\n        let i = await C.users.getUserCount();\n        console.info(`Syncing user count quota to ${i}`), t.usageQuota.users = i, await ke.setUsage(i, Va.StaticQuotaName.USERS, Va.QuotaUsageType.STATIC);\n      }\n      let r = await C.installation.getInstallFromDB(), a = C.tenancy.getTenantId(), n = await C.events.identification.getUniqueTenantId(a), o = Wr.getProVersion(), s = { quotaUsage: t, tenantId: a, install: { id: r.installId, tenantId: n, version: o } };\n      try {\n        let i = await Ya.post(\"/api/license\", { headers: { ...e }, body: s });\n        if (i.status === 404 || i.status === 403)\n          return;\n        if (i.status !== 200) {\n          let p = await Ha(i);\n          throw new C.HTTPError(`Error getting license: ${p}`, i.status);\n        }\n        return i.json();\n      } catch (i) {\n        if (C.env.DISABLE_ACCOUNT_PORTAL)\n          return;\n        throw i;\n      }\n    }))",
      "getLicenseFromKey": "async function To(e) {\n      return await wo.tracer.trace(\"getLicenseFromKey\", async (t) => {\n        let r;\n        if (!C.env.ACCOUNT_PORTAL_API_KEY)\n          throw new Error(\"getLicenseFromKey requires ACCOUNT_PORTAL_API_KEY to be set\");\n        try {\n          r = await Ya.get(`/api/license/${e}`, { headers: { [C.constants.Header.API_KEY]: C.env.ACCOUNT_PORTAL_API_KEY } });\n        } catch (a) {\n          if (C.env.DISABLE_ACCOUNT_PORTAL)\n            return;\n          throw a;\n        }\n        if (r.status === 404 || r.status === 403) {\n          t.addTags({ licenseFound: false });\n          return;\n        }\n        if (r.status !== 200) {\n          let a = await Ha(r);\n          throw new C.HTTPError(`Error getting license: ${a}`, r.status);\n        }\n        return r.json();\n      });\n    }",
      "triggerQuota": "(e) => Sp(async (t) => {\n      let r = await Ya.post(\"/api/license/usage/triggered\", { headers: { ...t }, body: e });\n      if (r.status !== 200) {\n        let a = await Ha(r);\n        C.logging.logAlert(`Error triggering quota usage: ${a}`);\n      }\n    })"
    },
    "features": {
      "getFeatures": "function Ro(e, t) {\n      let r = [];\n      function a(n) {\n        let o = n[t];\n        if (!o)\n          throw new Error(`Features do not exist for planType=${t} and hosting=${e}`);\n        return o;\n      }\n      switch (e) {\n        case l.Hosting.SELF:\n          r = a(vS);\n          break;\n        case l.Hosting.CLOUD:\n          r = a(ES);\n          break;\n      }\n      return r;\n    }"
    },
    "getFreeLicense": "() => ss.env.SELF_HOSTED ? ge.SELF_FREE_LICENSE : ge.CLOUD_FREE_LICENSE",
    "getLicense": "async () => await hf.tracer.trace(\"getLicense\", async (e) => {\n      if (ss.env.OFFLINE_MODE)\n        return e.addTags({ offline: true }), as();\n      let t = await Wt();\n      return t || (e.addTags({ offlineFallback: true }), t = ma.getOfflineLicense()), t;\n    })",
    "getLicenseFromKey": "(e) => To(e)",
    "keys": {
      "activateLicenseKey": "async function mx(e) {\n      await vo(e), await Te.save({ licenseKey: e }), await xt();\n    }",
      "deleteLicenseKey": "async function gx() {\n      return await cs.default.trace(\"deleteLicenseKey\", async () => {\n        await Te.save({ licenseKey: void 0 }), await xt();\n      });\n    }",
      "getLicenseKey": "async function mn() {\n      return await cs.default.trace(\"getLicenseKey\", async (e) => {\n        let t = await Te.get();\n        return e.addTags({ licenseKey: t.licenseKey }), t.licenseKey;\n      });\n    }"
    },
    "offline": {
      "activateOfflineLicenseToken": "async function ox(e) {\n      await Te.save({ offlineLicenseToken: e }), await xt();\n    }",
      "deleteOfflineLicenseToken": "async function sx() {\n      await Te.save({ offlineLicenseToken: void 0 }), await xt();\n    }",
      "dev": {
        "deleteDevLicense": "function fx() {\n      Ot.default.rmSync(fa, { force: true });\n    }",
        "getOfflineLicense": "function lx() {\n      try {\n        if (Ot.default.existsSync(fa)) {\n          let e = Ot.default.readFileSync(fa, { encoding: \"utf-8\" });\n          return Vr(e);\n        }\n      } catch (e) {\n        console.error(\"Error retrieving offline license from disk\", e);\n      }\n    }",
        "writeDevLicenseToDisk": "function dx(e) {\n      console.log(`Writing license to: ${fa}`), Ot.default.writeFileSync(fa, e, { encoding: \"utf-8\" });\n    }"
      },
      "enrichLicense": "function mf(e) {\n      let t = e.plan.type, r = uf.Hosting.SELF, a = Ro(r, t), n = _o(r, t);\n      return e.features = (0, pf.default)(e.features, a), e.quotas = (0, cf.default)(e.quotas, n), e;\n    }",
      "getIdentifier": "async function rs() {\n      let t = (await or.installation.getInstall()).installId, r = or.context.getTenantId(), a = await or.events.identification.getUniqueTenantId(r);\n      return { installId: t, tenantId: a };\n    }",
      "getIdentifierBase64": "async function ix() {\n      let e = await rs();\n      return $t.objectToBase64(e);\n    }",
      "getIdentifierFromBase64": "function ux(e) {\n      return $t.base64ToObject(e);\n    }",
      "getOfflineLicense": "async function as() {\n      try {\n        let e = await lf();\n        if (e) {\n          let t = await Vr(e);\n          return df(t), await ff(t), mf(t);\n        }\n      } catch (e) {\n        console.error(\"Error retrieving offline license\", e);\n      }\n    }",
      "getOfflineLicenseToken": "async function lf() {\n      return (await Te.get()).offlineLicenseToken;\n    }",
      "signing": {
        "sign": "function TS(e, t) {\n      return Eo.default.sign(t, e, { encoding: \"utf-8\", algorithm: \"RS256\" });\n    }",
        "verifyLicenseToken": "function Vr(e) {\n      return Eo.default.verify(e, wS, { algorithms: [\"RS256\"] });\n    }"
      },
      "verifyExpiry": "function df(e) {\n      let t = Date.now(), r = new Date(e.expireAt).getTime();\n      if (t > r)\n        throw new Error(`Offline license has expired. expireAt=${e.expireAt}`);\n    }",
      "verifyInstallation": "async function ff(e) {\n      let t = await rs();\n      if (e.identifier.installId !== t.installId || e.identifier.tenantId !== t.tenantId)\n        throw new Error(\"Invalid offline license\");\n    }"
    },
    "quotas": {
      "UNLIMITED": -1,
      "getQuotas": "function _o(e, t) {\n      let r;\n      function a(n) {\n        let o = n[t];\n        if (!o)\n          throw new Error(`Quotas do not exist for planType=${t} and hosting=${e}`);\n        return o;\n      }\n      switch (e) {\n        case G.Hosting.SELF:\n          r = a(_S);\n          break;\n        case G.Hosting.CLOUD:\n          r = a(RS);\n          break;\n      }\n      return JSON.parse(JSON.stringify(r));\n    }"
    }
  },
  "logger": {
    "logRequest": "async function qM(e) {\n      $i.logging.logWarn(\"SCIM request log\", e);\n    }",
    "logResponse": "async function DM(e) {\n      $i.logging.logWarn(\"SCIM response error\", e);\n    }"
  },
  "mappers": {
    "group": {
      "fromScimGroup": "(e) => {\n      let t = TG(e) ? e : void 0;\n      return { _id: t?.id, name: e.displayName, scimInfo: { externalId: e.externalId, isSync: true }, icon: \"UserGroup\", color: \"var(--spectrum-global-color-blue-600)\", createdAt: t?.meta.created.getTime(), updatedAt: t?.meta.lastModified.toISOString() };\n    }",
      "toScimGroupResponse": "(e) => ({ schemas: [\"urn:ietf:params:scim:schemas:core:2.0:Group\"], id: e._id, externalId: e.scimInfo.externalId, meta: { resourceType: \"Group\", created: new Date(e.createdAt), lastModified: new Date(e.updatedAt) }, displayName: e.name, members: e.users?.map((t) => ({ value: t._id })) })"
    },
    "user": {
      "fromScimUser": "(e) => {\n      let t = AG(e) ? e : void 0, r = bG(e);\n      if (!r)\n        throw new Error(\"Email is required\");\n      let a;\n      switch (e.active) {\n        case \"True\":\n        case \"true\":\n        case true:\n          a = true;\n          break;\n        case \"False\":\n        case \"false\":\n        case false:\n          a = false;\n          break;\n        default:\n          yG(e.active);\n      }\n      let n, o;\n      return e.name?.givenName ? (n = e.name?.givenName, o = e.name?.familyName) : n = e.displayName, { tenantId: \"\", _id: t?.id, userId: t?.id, email: r, firstName: n, lastName: o, scimInfo: { ...e, isSync: true }, roles: {}, status: a ? Xn.UserStatus.ACTIVE : Xn.UserStatus.INACTIVE, createdAt: t?.meta.created.getTime(), updatedAt: t?.meta.lastModified.toISOString() };\n    }",
      "toScimUserResponse": "(e) => {\n      let { isSync: t, roles: r, ...a } = e.scimInfo || {}, n = { ...a, schemas: [\"urn:ietf:params:scim:schemas:core:2.0:User\"], id: e._id, meta: { resourceType: \"User\", created: new Date(e.createdAt), lastModified: new Date(e.updatedAt) }, active: e.status === Xn.UserStatus.ACTIVE };\n      return (e.firstName || e.lastName) && (n.name = { formatted: [e.firstName, e.lastName].filter((o) => o).join(\" \"), familyName: e.lastName, givenName: e.firstName }), n;\n    }",
      "userFilters": "(e) => {\n      let t = { equal: {} }, r = (0, nI.parse)(e);\n      function a(n) {\n        switch (n.op) {\n          case \"eq\": {\n            let o = n.attrPath, s;\n            switch (o) {\n              case \"emails.value\":\n                s = \"email\";\n                break;\n              default:\n                s = `scimInfo.${o}`;\n            }\n            t.equal[s] = n.compValue;\n            break;\n          }\n          case \"and\":\n            for (let o of n.filters)\n              a(o);\n            break;\n          default:\n            console.warn(\"Filter not handled\", { filter: n });\n        }\n      }\n      return a(r), t;\n    }"
    }
  },
  "middleware": {
    "doInScimContext": "async (e, t) => (Kn.env.DISABLE_SCIM_CALLS || await Nt.logRequest({ ...e.request.toJSON(), body: e.request.body }), await Kn.context.doInScimContext(async () => {\n      let r = await t();\n      return await Nt.logResponse({ ...e.response.toJSON(), body: e.response.body }), r;\n    }))",
    "feature": {
      "requireFeature": "(e) => async (t, r) => {\n      await yn(e), await r();\n    }",
      "requireFeatures": "(...e) => async (t, r) => {\n      await ds(e), await r();\n    }"
    },
    "internalGroupOnly": "(e) => Hi(M.get, e, false)",
    "licenseAuth": "async function NA(e, t) {\n      await zi.tracer.trace(\"licenseAuth\", async (r) => {\n        let a = e.request.headers[_a.constants.Header.LICENSE_KEY];\n        Array.isArray(a) && (a = a[0]), r.addTags({ licenseKey: a }), a || e.throw(403, \"License key not provided\");\n        let n = await us(a);\n        n || (r.addTags({ licenseFound: false }), e.throw(403, \"License not found or invalid\")), n.tenantId || e.throw(403, \"License does not have a tenant ID\"), zi.tracer.setUser({ id: \"anonymous\", tenantId: n.tenantId }), await _a.context.doInSelfHostTenantUsingCloud(n.tenantId, async () => {\n          await _a.context.doInLicenseContext(n, async () => {\n            await t();\n          });\n        });\n      });\n    }",
    "licensing": "(e = { checkUsersLimit: true }) => async (t, r) => {\n      if ((e.licensingCheck ? e.licensingCheck : () => !!t.user)(t)) {\n        if (bt.env.SELF_HOSTED && bt.env.DEFAULT_LICENSE)\n          return t.user.license = Io, r();\n        t.user.license = await je.cache.getCachedLicense(t, { populateLicense: e.populateLicense, populateFreeLicense: e.populateFreeLicense }), e.checkUsersLimit && (bt.utils.isServingApp(t) || bt.utils.isServingBuilder(t) || bt.utils.isServingBuilderPreview(t) || bt.utils.isPublicApiRequest(t)) && await Ke.usageLimitIsExceeded($n.StaticQuotaName.USERS, $n.QuotaUsageType.STATIC);\n      }\n      return r();\n    }",
    "requireSCIM": "async (e, t) => {\n      await ys(), await t();\n    }",
    "scimGroupOnly": "(e) => Hi(M.get, e, true)",
    "scimUserOnly": "(e) => Hi(DA.users.getById, e, true)"
  },
  "plugins": {
    "checkPluginQuotas": "async function rO() {\n      let e = J.tenancy.getGlobalDB();\n      try {\n        let r = (await e.allDocs(J.db.getPluginParams())).rows.length;\n        console.log(`Syncing plugin count: ${r}`), await vs(r);\n      } catch (t) {\n        J.logging.logAlert(\"Unable to retrieve plugins for quota check\", t);\n      }\n    }",
    "deletePlugin": "async function tO(e) {\n      let t = J.tenancy.getGlobalDB();\n      try {\n        let r = await t.get(e), a = J.objectStore.getPluginS3Dir(r.name);\n        await J.objectStore.deleteFolder(J.objectStore.ObjectStoreBuckets.PLUGINS, a), await t.remove(e, r._rev), await J.events.plugin.deleted(r), await Ts();\n      } catch (r) {\n        let a = r?.message ? r?.message : r;\n        throw new Error(`Failed to delete plugin: ${a}`);\n      }\n    }",
    "storePlugin": "async function eO(metadata, directory, source) {\n      let db = J.tenancy.getGlobalDB(), version = metadata.package.version, name = metadata.package.name, description = metadata.package.description, hash = metadata.schema.hash, bucketPath = J.objectStore.getPluginS3Dir(name), files = await J.objectStore.uploadDirectory(J.objectStore.ObjectStoreBuckets.PLUGINS, directory, bucketPath), jsFile = files.find((e) => e.name.endsWith(\".js\")), iconFile = files.find((e) => e.name.endsWith(\".svg\"));\n      if (!jsFile)\n        throw new Error(\"Plugin missing .js file.\");\n      if (metadata.schema.type === $f.PluginType.DATASOURCE) {\n        let js = Wf(directory, jsFile.name);\n        try {\n          eval(js);\n        } catch (e) {\n          let t = e?.message ? e.message : JSON.stringify(e);\n          throw new Error(`JS invalid: ${t}`);\n        }\n      }\n      let iconFileName = iconFile ? iconFile.name : null, pluginId = J.db.generatePluginID(name), rev;\n      try {\n        rev = (await db.get(pluginId))._rev;\n      } catch (e) {\n        rev = void 0;\n      }\n      let doc = { _id: pluginId, _rev: rev, ...metadata, name, version, hash, description, source };\n      iconFileName && (doc.iconFileName = iconFileName), source && (doc = { ...doc, source });\n      let write = async () => {\n        let e = await db.put(doc);\n        return await J.events.plugin.imported(doc), { ...doc, _rev: e.rev };\n      };\n      return rev ? await write() : await ws(write);\n    }"
  },
  "publicApi": {
    "applications": {
      "buildExportFn": "function vO(e) {\n      return async (t, r) => {\n        await tt() || t.throw(403, \"Endpoint unavailable, license required.\");\n        let { encryptPassword: a, excludeRows: n } = t.request.body;\n        await $s.context.doInAppContext(t.params.appId, async () => {\n          t.request.body = { encryptPassword: a, excludeRows: n }, t.query.appId = t.params.appId, await e(t), await r();\n        });\n      };\n    }",
      "buildImportFn": "function TO(e) {\n      return async (t, r) => {\n        await tt() || t.throw(403, \"Endpoint unavailable, license required.\"), t.request.files?.appExport || t.throw(400, \"Must provide app export file for import.\"), await $s.context.doInAppContext(t.params.appId, async () => {\n          await e(t), t.body = void 0, t.status = 204, await r();\n        });\n      };\n    }"
    },
    "roles": {
      "assign": "async function SO(e, t) {\n      if (!await tt())\n        throw new Error(\"Unable to assign roles - license required.\");\n      let r = await Ve.bulkGet(e);\n      for (let a of r) {\n        if (t.role && t.role.roleId) {\n          let n = wa.db.getProdAppID(t.role.appId);\n          a.roles[n] = t.role.roleId;\n        }\n        if (t.appBuilder) {\n          let n = wa.db.getProdAppID(t.appBuilder.appId), o = a.builder?.apps || [];\n          a.builder = { apps: o.concat([n]) };\n        }\n        t.builder && (a.builder = { global: true }), t.admin && (a.admin = { global: true }), a.roles;\n      }\n      await Ve.bulkUpdate(r);\n    }",
      "unAssign": "async function wO(e, t) {\n      if (!await tt())\n        throw new Error(\"Unable to un-assign roles - license required.\");\n      let r = await Ve.bulkGet(e);\n      for (let a of r) {\n        if (t.role) {\n          let n = wa.db.getProdAppID(t.role?.appId);\n          a.roles[n] === t.role.roleId && delete a.roles[n];\n        }\n        if (t.appBuilder && a.builder?.apps) {\n          let n = wa.db.getProdAppID(t.appBuilder.appId);\n          a.builder.apps = a.builder.apps.filter((o) => o !== n);\n        }\n        t.builder && a.builder && delete a.builder, t.admin && a.admin && delete a.admin;\n      }\n    }"
    },
    "users": {
      "roleCheck": "async function IO(e, t) {\n      return await tt() || bO(e, t), e;\n    }"
    }
  },
  "quotas": {
    "addAction": "async (e) => Ae(bn.MonthlyQuotaName.ACTIONS, bn.QuotaUsageType.MONTHLY, { fn: e })",
    "addApp": "async (e, { appId: t } = {}) => Ae(ur.StaticQuotaName.APPS, ur.QuotaUsageType.STATIC, { fn: e, valueFn: _f, id: t })",
    "addAutomation": "async (e, { automationId: t } = {}) => Ae(In.MonthlyQuotaName.AUTOMATIONS, In.QuotaUsageType.MONTHLY, { fn: e, id: t })",
    "addGroup": "async (e) => Ae(pr.StaticQuotaName.USER_GROUPS, pr.QuotaUsageType.STATIC, { fn: e })",
    "addPlugin": "async (e) => Ae(ht.StaticQuotaName.PLUGINS, ht.QuotaUsageType.STATIC, { fn: e })",
    "addRow": "async (e, { tableId: t } = {}) => Ae(We.StaticQuotaName.ROWS, We.QuotaUsageType.STATIC, { fn: e, id: t })",
    "addRows": "async (e, t, { tableId: r } = {}) => Pt({ change: e, name: We.StaticQuotaName.ROWS, type: We.QuotaUsageType.STATIC, opts: { fn: t, id: r } })",
    "addUsers": "async (e, t, r) => {\n      let a = [{ change: e, name: $e.StaticQuotaName.USERS, type: $e.QuotaUsageType.STATIC, opts: { fn: r, valueFn: ya.users.getUserCount } }];\n      t > 0 && a.push({ change: t, name: $e.StaticQuotaName.CREATORS, type: $e.QuotaUsageType.STATIC, opts: { valueFn: ya.users.getCreatorCount } });\n      let n = await Pt(a);\n      return await Wt(), n;\n    }",
    "bustCache": "async function mo(e = 0) {\n      let r = Fa(), a = Er(), n = await r.tryGet(a);\n      n && n._rev && await r.remove(a, n._rev).catch(async (o) => {\n        if (e < 1)\n          return await mo(e + 1);\n        throw o;\n      });\n    }",
    "decrement": "(e, t, r = {}) => ir({ usageChange: -1, name: e, type: t, opts: r })",
    "decrementMany": "(e) => {\n      let t = Array.isArray(e) ? e : [e];\n      return ir(t.map((r) => ({ usageChange: -r.change, name: r.name, type: r.type, opts: r.opts })));\n    }",
    "getCurrentUsageValues": "async (e, t, r) => {\n      let a = await Tt(), n = 0, o = {};\n      switch (e) {\n        case ne.QuotaUsageType.STATIC:\n          if (a.usageQuota[t]) {\n            let s = t;\n            n = a.usageQuota[s], o = Vu(a, e, t, r);\n          }\n          break;\n        case ne.QuotaUsageType.MONTHLY: {\n          let s = ct(), i = t;\n          a.monthly[s][i] && (n = a.monthly[s][i], o = Vu(a, e, t, r));\n          break;\n        }\n        default:\n          throw new Error(`Invalid usage type: ${e}`);\n      }\n      return ne.APP_QUOTA_NAMES.includes(t) && !(o.app || o.breakdown) && (o.app = o.app || 0, o.breakdown = o.breakdown || 0), { total: n, app: o.app, breakdown: o.breakdown };\n    }",
    "getLicensedQuota": "async (e, t, r) => {\n      let a = await Pe.getCachedLicense();\n      if (!a) {\n        let n = De.tenancy.getTenantId();\n        throw new Error(\"License not found for tenant id \" + n);\n      }\n      if (r && (0, z.isStaticQuota)(e, r, t))\n        return a.quotas[e][r][t];\n      if (r && (0, z.isMonthlyQuota)(e, r, t))\n        return a.quotas[e][r][t];\n      if ((0, z.isConstantQuota)(e, t))\n        return a.quotas[e][t];\n      throw new Error(\"Invalid quota type\");\n    }",
    "getQuotaUsage": "async () => {\n      let e = Fa(), t = await e.tryGet(Er());\n      if (!t) {\n        t = fo();\n        let { rev: r } = await e.put(t);\n        t._rev = r;\n      }\n      return Ga(t), lo(t), MI(t);\n    }",
    "increment": "(e, t, r) => vf({ change: 1, name: e, type: t, opts: r })",
    "incrementBudibaseAICredits": "async (e) => Pt({ change: e, name: wn.MonthlyQuotaName.BUDIBASE_AI_CREDITS, type: wn.QuotaUsageType.MONTHLY })",
    "incrementMany": "(e) => sr.tracer.trace(\"quotas.incrementMany\", async () => vf(e))",
    "removeApp": "async ({ appId: e } = {}) => rt(ur.StaticQuotaName.APPS, ur.QuotaUsageType.STATIC, { valueFn: _f, id: e })",
    "removeGroup": "async () => rt(pr.StaticQuotaName.USER_GROUPS, pr.QuotaUsageType.STATIC)",
    "removePlugin": "async () => rt(ht.StaticQuotaName.PLUGINS, ht.QuotaUsageType.STATIC)",
    "removeRow": "async ({ tableId: e } = {}) => rt(We.StaticQuotaName.ROWS, We.QuotaUsageType.STATIC, { id: e })",
    "removeRows": "async (e, { tableId: t } = {}) => ga({ change: e, name: We.StaticQuotaName.ROWS, type: We.QuotaUsageType.STATIC, opts: { id: t } })",
    "removeUsers": "async (e, t) => {\n      let r = [{ change: e, name: $e.StaticQuotaName.USERS, type: $e.QuotaUsageType.STATIC, opts: { valueFn: ya.users.getUserCount } }];\n      t > 0 && r.push({ change: t, name: $e.StaticQuotaName.CREATORS, type: $e.QuotaUsageType.STATIC, opts: { valueFn: ya.users.getCreatorCount } }), await ga(r), await Wt();\n    }",
    "set": "async (e, t, r) => ke.setUsage(r, e, t)",
    "setAllUsage": "async (e) => {\n      let t = Array.isArray(e) ? e : [e], r = Fa(), a = await Tt();\n      for (let o of t)\n        a = zu(a, o.name, o.type, o.values, o.opts);\n      let n = await r.put(a, 0);\n      return a._rev = n.rev, a;\n    }",
    "setAppUsageValue": "(e, t, r, a = {}, n) => {\n      let o;\n      try {\n        o = ce.db.getProdAppID(a?.appId || ce.context.getAppId());\n      } catch {\n      }\n      if (!o || !n.app || !ne.APP_QUOTA_NAMES.includes(t))\n        return e;\n      e.apps?.[o] || (e.apps = { ...e.apps, [o]: Ma() });\n      let s = e.apps[o];\n      switch (r) {\n        case ne.QuotaUsageType.STATIC:\n          s.usageQuota[t] = n.app;\n          break;\n        case ne.QuotaUsageType.MONTHLY: {\n          let i = ct(), p = t, f = s.monthly[i];\n          f || (s.monthly[i] = Rr(), f = s.monthly[i]), f[p] = n.app, ne.BREAKDOWN_QUOTA_NAMES.includes(p) && a?.id && (f = GI(f, p, a.id, n));\n          break;\n        }\n      }\n      return e;\n    }",
    "setUsage": "async (e, t, r) => yo({ name: t, type: r, values: { total: e } })",
    "setUsagePerApp": "async (e, t, r) => {\n      let a = Fa(), n = await Tt(), o = Object.values(e).reduce((i, p) => i + p, 0);\n      for (let [i, p] of Object.entries(e))\n        n = zu(n, t, r, { total: o, app: p }, { appId: i });\n      let s = await a.put(n);\n      return n._rev = s.rev, n;\n    }",
    "updatePluginCount": "async (e) => bs(ht.StaticQuotaName.PLUGINS, ht.QuotaUsageType.STATIC, e)",
    "updateUsage": "async (e) => {\n      await sr.tracer.trace(\"quotas.updateUsage\", async (t) => {\n        let r = De.tenancy.getTenantId(), a = Array.isArray(e) ? e : [e];\n        t.addTags({ numActions: a.length, tenantId: r });\n        let n, o, s = [], i = {}, p = {}, f = {}, m = {};\n        for (let g of a)\n          await sr.tracer.trace(\"quotas.updateUsage.action\", async (I) => {\n            I.addTags({ actionName: g.name, actionType: g.type, actionUsageChange: g.usageChange });\n            try {\n              n = De.context.getAppId();\n            } catch {\n            }\n            if (z.APP_QUOTA_NAMES.includes(g.name) && !n)\n              throw new Error(\"App context required for quota update\");\n            try {\n              o = await Ef(z.QuotaType.USAGE, g.name, g.type), s.push(o);\n              let { total: _6, app: R, breakdown: E } = await ke.getCurrentUsageValues(g.type, g.name, g.opts?.id);\n              _6 += g.usageChange, R != null && (R += g.usageChange), E != null && (E += g.usageChange);\n              let U = {};\n              if (g.opts?.dryRun || (U = await xx(g.type, g.name, _6, o), m = { ...m, [g.name]: U }), o.value !== Ze.UNLIMITED && _6 > o.value && g.usageChange > 0)\n                throw new De.UsageLimitError(`Licensed ${o.name} of ${o.value} has been exceeded`, o.name);\n              if (_6 = Math.max(0, _6), R && (R = Math.max(0, R)), E && (E = Math.max(0, E), f = { ...f, [g.name]: E }), !g.opts?.dryRun) {\n                let Le = g.opts?.valueFn;\n                Le && (_6 = await Le(), R = _6), i = { ...i, [g.name]: _6 }, p = { ...p, [g.name]: R };\n              }\n            } catch (_6) {\n              throw g.opts?.suppressErrorLog || console.error(`Error updating usage quotas for ${g.name}`, _6), _6;\n            }\n          });\n        let y = a.filter((g) => !g.opts?.dryRun).map((g) => ({ name: g.name, type: g.type, values: { total: i[g.name], app: p[g.name], breakdown: f[g.name], triggers: m[g.name] }, opts: { ...g.opts, tenantId: r } }));\n        y.length > 0 && await ke.setAllUsage(y);\n      });\n    }",
    "usageLimitIsExceeded": "async (e, t) => {\n      try {\n        return await ir({ usageChange: 1, name: e, type: t, opts: { dryRun: true } }), false;\n      } catch (r) {\n        if (r.code === z.ErrorCode.USAGE_LIMIT_EXCEEDED)\n          return true;\n        throw r;\n      }\n    }",
    "utils": {
      "generateBaseQuotaUsage": "() => ({ usageQuota: { [H.StaticQuotaName.APPS]: 0, [H.StaticQuotaName.ROWS]: 0, [H.StaticQuotaName.PLUGINS]: 0, [H.StaticQuotaName.USERS]: 0, [H.StaticQuotaName.CREATORS]: 0, [H.StaticQuotaName.USER_GROUPS]: 0, [H.StaticQuotaName.AI_CUSTOM_CONFIGS]: 0, triggers: {} }, monthly: { [ct()]: Rr() } })",
      "generateNewMonthlyQuotas": "() => ({ [H.MonthlyQuotaName.QUERIES]: 0, [H.MonthlyQuotaName.AUTOMATIONS]: 0, [H.MonthlyQuotaName.BUDIBASE_AI_CREDITS]: 0, [H.MonthlyQuotaName.ACTIONS]: 0, triggers: {} })",
      "generateNewQuotaUsage": "() => {\n      let e = { _id: Er(), quotaReset: Wu(), ...Ma(), apps: {} };\n      return Ga(e), e;\n    }",
      "getBreakdownName": "(e, t) => {\n      if (!(!t || !e))\n        switch (e) {\n          case H.MonthlyQuotaName.AUTOMATIONS:\n            return H.BreakdownQuotaName.AUTOMATIONS;\n          case H.MonthlyQuotaName.QUERIES:\n            return (0, Ba.isTableIdOrExternalTableId)(t) ? H.BreakdownQuotaName.ROW_QUERIES : (0, Ba.isDatasourceOrDatasourcePlusId)(t) ? H.BreakdownQuotaName.DATASOURCE_QUERIES : void 0;\n        }\n    }",
      "getCurrentMonthString": "() => {\n      let e = /* @__PURE__ */ new Date(), t = e.getMonth() + 1, r = e.getFullYear();\n      return `${t}-${r}`;\n    }",
      "getQuotaDocId": "() => vr.context.isSelfHostUsingCloud() ? `quota_usage_${vr.context.getTenantId()}` : vr.db.StaticDatabases.GLOBAL.docs.usageQuota",
      "setCurrentMonth": "(e) => {\n      let t = ct();\n      e.monthly || (e.monthly = {}), e.monthly[t] || (e.monthly[t] = Rr()), e.monthly.current = e.monthly[t];\n    }",
      "setQuotaReset": "(e) => {\n      e.quotaReset = Wu();\n    }"
    }
  },
  "scimGroups": {
    "create": "async function UM(e) {\n      let t = await Ao(e.name), r;\n      if (!t)\n        r = (await j.save(e)).id;\n      else {\n        if (t.scimInfo?.isSync)\n          throw new UA.HTTPError(\"Group is already synched\", 409);\n        r = t._id, t.users && (await j.removeUsers(r, t.users.map((n) => n._id)), delete t.users), t.scimInfo = (0, PA.default)(t.scimInfo, e.scimInfo), await j.save(t);\n      }\n      return await j.get(r);\n    }"
  },
  "scimUsers": {
    "create": "async function LM(e) {\n      let t = await Ve.getUserByEmail(e.email);\n      if (t) {\n        if (t.scimInfo?.isSync)\n          throw new st.HTTPError(\"User is already synched\", 409);\n        e = { ...t, scimInfo: (0, LA.default)(t.scimInfo, e.scimInfo), password: void 0, firstName: e.firstName, lastName: e.lastName, updatedAt: e.updatedAt };\n      }\n      return await Ve.save(e, { requirePassword: false });\n    }",
    "find": "async function OM(e) {\n      return await st.users.getById(e);\n    }",
    "get": "async function xM(e) {\n      let t = st.tenancy.getGlobalDB(), r = new st.db.QueryBuilder(t.name, CA.SearchIndex.USER);\n      r.setIndexBuilder(st.db.searchIndexes.createUserIndex), r.setLimit(e.pageSize), r.addEqual(\"scimInfo.isSync\", true);\n      for (let [n, o] of Object.entries(e.filters?.equal ?? {}))\n        r.addEqual(n, o);\n      r.setSort(\"_id\"), r.setSkip(e.skip);\n      let a = await r.run();\n      return { users: a.rows, total: a.totalRows };\n    }",
    "remove": "async function PM(e) {\n      return await Ve.destroy(e);\n    }",
    "update": "async function CM(e, t) {\n      return await Ve.save(e, { requirePassword: false, allowChangingEmail: t?.allowChangingEmail });\n    }"
  },
  "sdk": {
    "ai": {
      "enrichAIConfig": "async function hs(e) {\n      if (Tf.env.SELF_HOSTED)\n        return e;\n      for (let t of Object.values(e.config))\n        if (t.provider === \"BudibaseAI\")\n          return e;\n      return e.config[Ex] = { provider: \"BudibaseAI\", active: true, isDefault: Object.keys(e.config).every((t) => !e.config[t].isDefault), defaultModel: process.env.BUDIBASE_AI_DEFAULT_MODEL || \"gpt-4o-mini\", name: \"Budibase AI\" }, e;\n    }"
    },
    "auditLogs": {
      "definitions": "function AO() {\n      let e = Object.entries(Ln.AuditedEventFriendlyName).filter((r) => r[1] != null), t = {};\n      for (let r of e)\n        t[r[0]] = Fs(r[1]);\n      return t;\n    }",
      "download": "function hO(e) {\n      return e = Gs(e), Xf(e);\n    }",
      "fetch": "async function yO(e) {\n      if (!await hn())\n        throw new Error(\"Audit logs not available - license required.\");\n      let t = await Zf(e);\n      if (typeof e.bookmark == \"string\")\n        throw new Error(\"String based bookmark not supported.\");\n      let r = await Ms(t, e.bookmark);\n      return { hasNextPage: r.hasNextPage, bookmark: r.bookmark, data: await gO(r.rows) };\n    }",
      "write": "async function mO(e, t, r) {\n      if (!await hn() || !le.utils.isAudited(e))\n        return;\n      let a = em(e, t), n = /* @__PURE__ */ new Date();\n      r?.timestamp && (n = new Date(r.timestamp));\n      let o = { timestamp: n.toISOString(), event: e, name: a, userId: r?.userId || Ln.AuditLogSystemUser, metadata: { ...t, ...r?.hostInfo } }, s = {};\n      try {\n        if (r?.appId) {\n          o.appId = le.db.getProdAppID(r.appId);\n          let i = await le.cache.app.getAppMetadata(r.appId);\n          \"name\" in i && (s.appName = i.name);\n        }\n        if (r?.userId) {\n          let i = await le.users.getById(r?.userId);\n          s.email = i.email;\n        }\n      } catch (i) {\n        le.logging.logAlert(\"Failed to retrieve fallback information for audit log\", i);\n      }\n      return o.fallback = s, await Jf(o);\n    }"
    },
    "automations": {
      "logs": {
        "logSearch": "async function Xx(e) {\n      return await Ns(), await Jx(e.startDate, e.status, e.automationId, e.page);\n    }",
        "oldestLogDate": "async () => $a(En.ConstantQuotaName.AUTOMATION_LOG_RETENTION_DAYS)",
        "storeLog": "async function Zx(e, t) {\n      if (!Rn.db.isProdAppID(Rn.context.getAppId()))\n        return;\n      let r = await Gf(e, t);\n      t.status === kf.AutomationStatus.ERROR && await Ds([r]), await Ns();\n    }"
      }
    },
    "backups": {
      "isEnabled": "async function fs() {\n      return ie(se.Feature.APP_BACKUPS);\n    }",
      "triggerAppRestore": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "triggerAppBackup": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "getBackupDownloadStream": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "downloadAppBackup": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "fetchAppBackups": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "storeAppBackupMetadata": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "updateBackupStatus": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "updateRestoreStatus": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "getAppBackup": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "updateAppBackup": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "deleteAppBackup": "async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t))",
      "processing": {
        "init": "async function Hs(e) {\n      qt().process(async (t) => {\n        let r = t.data;\n        try {\n          if (r.export)\n            return console.log(\"Exporting app backup:\", r.appId, r.export.trigger), NO(t, e);\n          if (r.import)\n            return console.log(\"Importing app backup:\", r.appId, r.import.backupId), DO(t, e);\n        } catch (a) {\n          W.logging.logAlert(`Failed to perform backup for app ID: ${r.appId}`, a);\n        }\n      });\n    }"
      },
      "init": "async (e) => {\n      rm(), await Hs(e.processing);\n    }",
      "getBackupQueue": "function qt() {\n      return tm;\n    }"
    },
    "branding": {
      "getBrandingConfig": "async function vx(e) {\n      return await ms() ? { faviconUrl: e.faviconUrl, faviconUrlEtag: e.faviconUrlEtag, emailBrandingEnabled: e.emailBrandingEnabled, testimonialsEnabled: e.testimonialsEnabled, platformTitle: e.platformTitle, loginHeading: e.loginHeading, loginButton: e.loginButton, metaDescription: e.metaDescription, metaImageUrl: e.metaImageUrl, metaTitle: e.metaTitle } : Tx;\n    }"
    },
    "environmentVariables": {
      "fetch": "async function nO() {\n      let e = await Rt.get();\n      return Object.keys(e.variables);\n    }",
      "fetchValues": "async function oO(e) {\n      let r = (await Rt.get()).variables, a = {};\n      for (let [n, o] of Object.entries(r))\n        switch (e) {\n          case ba.AppEnvironment.DEVELOPMENT:\n            a[n] = o.development;\n            break;\n          case ba.AppEnvironment.PRODUCTION:\n          default:\n            a[n] = o.production;\n            break;\n        }\n      return a;\n    }",
      "isEncryptionKeyAvailable": "function aO() {\n      return !!Kf.env.ENCRYPTION_KEY;\n    }",
      "isValid": "function Yf(e) {\n      return /^[a-zA-Z0-9-_]+$/.test(e);\n    }",
      "remove": "async function iO(e) {\n      await Vf((t) => (delete t[e], t));\n    }",
      "update": "async function sO(e, t) {\n      if (Yf(e))\n        await Vf((a) => (a[e] = t, a));\n      else\n        throw new Error(\"Variable name has characters that are not allowed\");\n    }"
    },
    "features": {
      "checkBackups": "function he(e) {\n      return async (...t) => (await yn(se.Feature.APP_BACKUPS), e(...t));\n    }",
      "checkFeature": "async function yn(e, t) {\n      if (!await ie(e, t))\n        throw new et.FeatureDisabledError(`${e} is not currently enabled`, e);\n    }",
      "checkFeatures": "async function ds(e, t) {\n      if (!await ie(e, t)) {\n        let r = e.join(\", \");\n        throw new et.FeatureDisabledError(`${r} are not currently enabled`, r);\n      }\n    }",
      "checkSCIM": "async () => {\n      let e = se.Feature.SCIM, t = await ie(e), r = await et.configs.getSCIMConfig();\n      if (!t || !r?.enabled)\n        throw new et.FeatureDisabledError(`${e} is not currently enabled`, e);\n      return true;\n    }",
      "isAppBuildersEnabled": "async function Ct() {\n      return ie(se.Feature.APP_BUILDERS);\n    }",
      "isAuditLogsEnabled": "async function hn() {\n      return ie(se.Feature.AUDIT_LOGS);\n    }",
      "isBackupsEnabled": "async function fs() {\n      return ie(se.Feature.APP_BACKUPS);\n    }",
      "isBrandingEnabled": "async function ms() {\n      return ie(se.Feature.BRANDING);\n    }",
      "isEnforceableSSO": "async function wf() {\n      return ie(se.Feature.ENFORCEABLE_SSO);\n    }",
      "isExpandedPublicApiEnabled": "async function tt() {\n      return ie(se.Feature.EXPANDED_PUBLIC_API);\n    }",
      "isPWAEnabled": "function bx() {\n      return ie(se.Feature.PWA);\n    }",
      "isSSOEnforced": "async function Ix(e) {\n      if (et.env.ENABLE_SSO_MAINTENANCE_MODE || !await wf())\n        return false;\n      let r;\n      return e?.config ? r = e.config : r = await et.configs.getSettingsConfig(), !!r.isSSOEnforced;\n    }",
      "isSyncAutomationsEnabled": "async function hx() {\n      return ie(se.Feature.SYNC_AUTOMATIONS);\n    }",
      "isTriggerAutomationRunEnabled": "async function Ax() {\n      return ie(se.Feature.TRIGGER_AUTOMATION_RUN);\n    }",
      "isUserGroupsEnabled": "async function gs() {\n      return ie(se.Feature.USER_GROUPS);\n    }",
      "isViewPermissionEnabled": "async function Sx() {\n      return ie(se.Feature.VIEW_PERMISSIONS);\n    }",
      "isViewReadonlyColumnsEnabled": "async function wx() {\n      return ie(se.Feature.VIEW_READONLY_COLUMNS);\n    }"
    },
    "groups": {
      "addAppBuilder": "async function Os(e, t) {\n      if (!await Ct())\n        throw new Error(\"Feature not enabled, please check license\");\n      let r = x.db.getProdAppID(t), a = await Ut(e);\n      a.builder ??= { apps: [] }, a.builder.apps.includes(t) || (a.builder.apps.push(r), await lr(a));\n    }",
      "addUsers": "async function Rs(e, t) {\n      let r = await M.get(e), a = await x.users.bulkGetGlobalUsersById(t), n = [];\n      for (let p of a)\n        p.userGroups || (p.userGroups = []), p.userGroups.includes(e) || n.push(p);\n      if (!n.length)\n        return n;\n      let o = n.map((p) => ({ ...p, userGroups: [...p?.userGroups || [], e] }));\n      if (await x.users.bulkUpdateGlobalUsers(o), Object.values(r.roles || {}).includes(\"CREATOR\")) {\n        let f = (await x.userUtils.creatorsInList(n)).filter((y) => y).length, m = n.length - f;\n        m && await Sn(0, m);\n      }\n      let i = [];\n      for (let p of t)\n        i.push(x.cache.user.invalidateUser(p));\n      return await Promise.all(i), await x.events.group.usersAdded(o.length, r), o;\n    }",
      "adjustGroupCreatorsQuotas": "async function Fx() {\n      if (!await gs()) {\n        let e = x.tenancy.getGlobalDB(), r = (await ha() || []).filter((a) => Object.values(a?.roles || {}).includes(\"CREATOR\"));\n        for (let a of r) {\n          let n = await M.getGroupUsers(a._id), s = (await Promise.all(n.map((m) => e.get(m._id)))).map((m) => ({ ...m, userGroups: m.userGroups.filter((y) => y !== a._id) })), p = (await x.userUtils.creatorsInList(s)).filter((m) => m).length, f = n.length - p;\n          await M.save({ ...a, roles: {} }), f && await cr(0, f);\n        }\n      }\n    }",
      "cleanupApp": "async function kx(e) {\n      let t = await ha(), r = [];\n      for (let a of t)\n        !a.roles || !a.roles[e] || (delete a.roles[e], r.push(a));\n      return await M.bulkSave(r);\n    }",
      "enrichUserRolesFromGroups": "async function Gx(e) {\n      if (!e || !e.userGroups)\n        return e;\n      let t = await qf(e.userGroups, { enriched: false }), r = [];\n      for (let n of t)\n        n?.roles && (r = r.concat(Object.keys(n.roles)));\n      r = [...new Set(r)];\n      for (let n of r)\n        await x.context.doInAppContext(n, async () => {\n          if (e.roles[n])\n            return;\n          let o = await Cf(t, n);\n          o && (e.roles[n] = o);\n        });\n      let a = await Uf(e, { groups: t });\n      if (a.length && !e.builder?.global) {\n        let n = e.builder?.apps || [];\n        e.builder = { apps: n.concat(a) };\n      }\n      return e;\n    }",
      "fetch": "async function ha() {\n      return await M.fetch();\n    }",
      "get": "async function Ut(e) {\n      return await M.get(e);\n    }",
      "getBulk": "async function qf(e, t = { enriched: true }) {\n      return await M.getBulk(e, t);\n    }",
      "getGroupBuilderAppIds": "async function Uf(e, t) {\n      if (!e.userGroups)\n        return [];\n      let r = await Pf(e.userGroups, t?.groups), a = t?.appId ? x.db.getProdAppID(t?.appId) : null, n = [];\n      for (let o of r) {\n        let s = o.builder?.apps;\n        a && s?.includes(a) ? n.push(a) : a || (n = n.concat(s || []));\n      }\n      return [...new Set(n)];\n    }",
      "getGroupRoleId": "async function Mx(e, t, r) {\n      if (!e.userGroups)\n        return null;\n      let a = await Pf(e.userGroups, r?.groups), n = x.db.getProdAppID(t);\n      return e.roles?.[n] ? e.roles[n] : (a = a.filter((o) => o?.roles ? Object.keys(o.roles).includes(n) : false), await Cf(a, t));\n    }",
      "remove": "async function Es(e, t) {\n      let r;\n      try {\n        r = await M.get(e);\n      } catch {\n        throw new Error(\"Group not found\");\n      }\n      let a = Object.values(r.roles || {}).includes(\"CREATOR\"), n = () => {\n      };\n      if (a) {\n        let s = x.tenancy.getGlobalDB(), i = await M.getGroupUsers(e), f = (await Promise.all(i.map((I) => s.get(I._id)))).map((I) => ({ ...I, userGroups: I.userGroups.filter((L) => L !== e) })), y = (await x.userUtils.creatorsInList(f)).filter((I) => I).length, g = i.length - y;\n        g && (n = () => cr(0, g));\n      }\n      let o = await M.destroy(e, t);\n      return await x.events.group.deleted(r), await Ss(), await n(), o;\n    }",
      "removeAppBuilder": "async function Ls(e, t) {\n      if (!await Ct())\n        throw new Error(\"Feature not enabled, please check license\");\n      let r = x.db.getProdAppID(t), a = await Ut(e);\n      a.builder?.apps.includes(t) && (a.builder.apps = a.builder.apps.filter((n) => n !== r), await lr(a));\n    }",
      "removeUsers": "async function _s(e, t) {\n      let r = await M.get(e), a = await x.users.bulkGetGlobalUsersById(t), n = [];\n      for (let i of a) {\n        if (!i.userGroups || !i.userGroups.includes(e))\n          continue;\n        let p = i.userGroups.indexOf(e);\n        i.userGroups.splice(p, 1), n.push(i);\n      }\n      if (await x.users.bulkUpdateGlobalUsers(n), Object.values(r.roles || {}).includes(\"CREATOR\")) {\n        let p = (await x.userUtils.creatorsInList(n)).filter((m) => m).length, f = n.length - p;\n        f && await cr(0, f);\n      }\n      let s = [];\n      for (let i of t)\n        s.push(x.cache.user.invalidateUser(i));\n      return await Promise.all(s), n.length && await x.events.group.usersDeleted(n.length, r), n;\n    }",
      "save": "async function lr(e) {\n      let t = [], r = !e._id, a = 0;\n      if (delete e.users, !e._id)\n        e._id = M.generateUserGroupID(), await Of(e.name), t.push(x.events.group.created(e));\n      else {\n        let o = await M.get(e._id);\n        if (o.name !== e.name && await Of(e.name), t.push(x.events.group.updated(e)), JSON.stringify(o.roles) !== JSON.stringify(e.roles)) {\n          let s = o.users?.length || 0, i = 0;\n          s > 0 && (i = await Lf(o)), Object.values(e.roles).includes(\"CREATOR\") ? a = s - i : a = -s, t.push(x.events.group.permissionsEdited(e));\n        }\n      }\n      await Promise.all(t);\n      let n = () => M.save(e);\n      if (r)\n        return await Is(n);\n      {\n        let o = await n();\n        if (a > 0)\n          await Sn(0, a);\n        else if (a < 0) {\n          let s = await Lf(e), i = Math.abs(a) - s;\n          i > 0 && await cr(0, i);\n        }\n        return o;\n      }\n    }",
      "updateGroupApps": "async function xs(e, t) {\n      let r = await Ut(e);\n      if (r.roles || (r.roles = {}), t.appsToAdd)\n        for (let a of t.appsToAdd)\n          r.roles[a.appId] = a.roleId;\n      if (t.appsToRemove)\n        for (let a of t.appsToRemove)\n          delete r.roles[a.appId];\n      return await lr(r);\n    }"
    },
    "init": "async (e) => {\n      e.backups && await Re.init(e.backups);\n    }",
    "licensing": {
      "cache": {
        "getCachedLicense": "async (e, t) => {\n      let { populateLicense: r = is, populateFreeLicense: a = ps } = t || {};\n      return await gn.default.trace(\"getCachedLicense\", async (n) => {\n        let o = Lt.context.getLicense();\n        if (o)\n          return n.addTags({ foundInContext: true, features: o.features, plan: o.plan, quotas: o.quotas }), o;\n        let s = Lt.tenancy.getTenantId(), i = await io(), p = await i.get(s);\n        return n.addTags({ tenantId: s, foundInCache: !!p }), p ? (n.addTags({ foundInCache: true, refreshedAt: p.refreshedAt, features: p.features, plan: p.plan, quotas: p.quotas }), p) : (p = await gn.default.trace(\"populateLicense\", async () => await r(s)), n.addTags({ populatedLicense: !!p }), p || (p = gn.default.trace(\"populateFreeLicense\", () => a(e, s)), n.addTags({ populatedFreeLicense: !!p })), p.refreshedAt = (/* @__PURE__ */ new Date()).toISOString(), n.addTags({ refreshedAt: p.refreshedAt, features: p.features, plan: p.plan, quotas: p.quotas, expirySeconds: Af }), await i.store(s, p, Af), p);\n      });\n    }",
        "invalidate": "async () => {\n      let e = Lt.tenancy.getTenantId();\n      await (await io()).delete(e);\n    }",
        "refresh": "async () => {\n      await Sf(), await If();\n    }"
      },
      "client": {
        "activateLicenseKey": "async (e) => {\n      let t = await C.installation.getInstall(), r = { installVersion: t.version, installId: t.installId }, a = await Ya.post(\"/api/license/activate\", { headers: { [C.constants.Header.LICENSE_KEY]: e }, body: r });\n      if (a.status === 403)\n        throw new C.HTTPError(\"Invalid license key\", 400);\n      if (a.status === 409)\n        throw new C.HTTPError(\"License key has already been activated\", 409);\n      if (a.status !== 200) {\n        let n = await Ha(a);\n        throw new C.HTTPError(`Error activating license key: ${n}`, a.status);\n      }\n      return a.json();\n    }",
        "getLicense": "async () => await wo.tracer.trace(\"_getLicense\", async () => await Sp(async (e) => {\n      let t = await ke.getQuotaUsage();\n      if (t.usageQuota.users == null) {\n        let i = await C.users.getUserCount();\n        console.info(`Syncing user count quota to ${i}`), t.usageQuota.users = i, await ke.setUsage(i, Va.StaticQuotaName.USERS, Va.QuotaUsageType.STATIC);\n      }\n      let r = await C.installation.getInstallFromDB(), a = C.tenancy.getTenantId(), n = await C.events.identification.getUniqueTenantId(a), o = Wr.getProVersion(), s = { quotaUsage: t, tenantId: a, install: { id: r.installId, tenantId: n, version: o } };\n      try {\n        let i = await Ya.post(\"/api/license\", { headers: { ...e }, body: s });\n        if (i.status === 404 || i.status === 403)\n          return;\n        if (i.status !== 200) {\n          let p = await Ha(i);\n          throw new C.HTTPError(`Error getting license: ${p}`, i.status);\n        }\n        return i.json();\n      } catch (i) {\n        if (C.env.DISABLE_ACCOUNT_PORTAL)\n          return;\n        throw i;\n      }\n    }))",
        "getLicenseFromKey": "async function To(e) {\n      return await wo.tracer.trace(\"getLicenseFromKey\", async (t) => {\n        let r;\n        if (!C.env.ACCOUNT_PORTAL_API_KEY)\n          throw new Error(\"getLicenseFromKey requires ACCOUNT_PORTAL_API_KEY to be set\");\n        try {\n          r = await Ya.get(`/api/license/${e}`, { headers: { [C.constants.Header.API_KEY]: C.env.ACCOUNT_PORTAL_API_KEY } });\n        } catch (a) {\n          if (C.env.DISABLE_ACCOUNT_PORTAL)\n            return;\n          throw a;\n        }\n        if (r.status === 404 || r.status === 403) {\n          t.addTags({ licenseFound: false });\n          return;\n        }\n        if (r.status !== 200) {\n          let a = await Ha(r);\n          throw new C.HTTPError(`Error getting license: ${a}`, r.status);\n        }\n        return r.json();\n      });\n    }",
        "triggerQuota": "(e) => Sp(async (t) => {\n      let r = await Ya.post(\"/api/license/usage/triggered\", { headers: { ...t }, body: e });\n      if (r.status !== 200) {\n        let a = await Ha(r);\n        C.logging.logAlert(`Error triggering quota usage: ${a}`);\n      }\n    })"
      },
      "features": {
        "getFeatures": "function Ro(e, t) {\n      let r = [];\n      function a(n) {\n        let o = n[t];\n        if (!o)\n          throw new Error(`Features do not exist for planType=${t} and hosting=${e}`);\n        return o;\n      }\n      switch (e) {\n        case l.Hosting.SELF:\n          r = a(vS);\n          break;\n        case l.Hosting.CLOUD:\n          r = a(ES);\n          break;\n      }\n      return r;\n    }"
      },
      "getFreeLicense": "() => ss.env.SELF_HOSTED ? ge.SELF_FREE_LICENSE : ge.CLOUD_FREE_LICENSE",
      "getLicense": "async () => await hf.tracer.trace(\"getLicense\", async (e) => {\n      if (ss.env.OFFLINE_MODE)\n        return e.addTags({ offline: true }), as();\n      let t = await Wt();\n      return t || (e.addTags({ offlineFallback: true }), t = ma.getOfflineLicense()), t;\n    })",
      "getLicenseFromKey": "(e) => To(e)",
      "keys": {
        "activateLicenseKey": "async function mx(e) {\n      await vo(e), await Te.save({ licenseKey: e }), await xt();\n    }",
        "deleteLicenseKey": "async function gx() {\n      return await cs.default.trace(\"deleteLicenseKey\", async () => {\n        await Te.save({ licenseKey: void 0 }), await xt();\n      });\n    }",
        "getLicenseKey": "async function mn() {\n      return await cs.default.trace(\"getLicenseKey\", async (e) => {\n        let t = await Te.get();\n        return e.addTags({ licenseKey: t.licenseKey }), t.licenseKey;\n      });\n    }"
      },
      "offline": {
        "activateOfflineLicenseToken": "async function ox(e) {\n      await Te.save({ offlineLicenseToken: e }), await xt();\n    }",
        "deleteOfflineLicenseToken": "async function sx() {\n      await Te.save({ offlineLicenseToken: void 0 }), await xt();\n    }",
        "dev": {
          "deleteDevLicense": "function fx() {\n      Ot.default.rmSync(fa, { force: true });\n    }",
          "getOfflineLicense": "function lx() {\n      try {\n        if (Ot.default.existsSync(fa)) {\n          let e = Ot.default.readFileSync(fa, { encoding: \"utf-8\" });\n          return Vr(e);\n        }\n      } catch (e) {\n        console.error(\"Error retrieving offline license from disk\", e);\n      }\n    }",
          "writeDevLicenseToDisk": "function dx(e) {\n      console.log(`Writing license to: ${fa}`), Ot.default.writeFileSync(fa, e, { encoding: \"utf-8\" });\n    }"
        },
        "enrichLicense": "function mf(e) {\n      let t = e.plan.type, r = uf.Hosting.SELF, a = Ro(r, t), n = _o(r, t);\n      return e.features = (0, pf.default)(e.features, a), e.quotas = (0, cf.default)(e.quotas, n), e;\n    }",
        "getIdentifier": "async function rs() {\n      let t = (await or.installation.getInstall()).installId, r = or.context.getTenantId(), a = await or.events.identification.getUniqueTenantId(r);\n      return { installId: t, tenantId: a };\n    }",
        "getIdentifierBase64": "async function ix() {\n      let e = await rs();\n      return $t.objectToBase64(e);\n    }",
        "getIdentifierFromBase64": "function ux(e) {\n      return $t.base64ToObject(e);\n    }",
        "getOfflineLicense": "async function as() {\n      try {\n        let e = await lf();\n        if (e) {\n          let t = await Vr(e);\n          return df(t), await ff(t), mf(t);\n        }\n      } catch (e) {\n        console.error(\"Error retrieving offline license\", e);\n      }\n    }",
        "getOfflineLicenseToken": "async function lf() {\n      return (await Te.get()).offlineLicenseToken;\n    }",
        "signing": {
          "sign": "function TS(e, t) {\n      return Eo.default.sign(t, e, { encoding: \"utf-8\", algorithm: \"RS256\" });\n    }",
          "verifyLicenseToken": "function Vr(e) {\n      return Eo.default.verify(e, wS, { algorithms: [\"RS256\"] });\n    }"
        },
        "verifyExpiry": "function df(e) {\n      let t = Date.now(), r = new Date(e.expireAt).getTime();\n      if (t > r)\n        throw new Error(`Offline license has expired. expireAt=${e.expireAt}`);\n    }",
        "verifyInstallation": "async function ff(e) {\n      let t = await rs();\n      if (e.identifier.installId !== t.installId || e.identifier.tenantId !== t.tenantId)\n        throw new Error(\"Invalid offline license\");\n    }"
      },
      "quotas": {
        "UNLIMITED": -1,
        "getQuotas": "function _o(e, t) {\n      let r;\n      function a(n) {\n        let o = n[t];\n        if (!o)\n          throw new Error(`Quotas do not exist for planType=${t} and hosting=${e}`);\n        return o;\n      }\n      switch (e) {\n        case G.Hosting.SELF:\n          r = a(_S);\n          break;\n        case G.Hosting.CLOUD:\n          r = a(RS);\n          break;\n      }\n      return JSON.parse(JSON.stringify(r));\n    }"
      }
    },
    "logger": {
      "logRequest": "async function qM(e) {\n      $i.logging.logWarn(\"SCIM request log\", e);\n    }",
      "logResponse": "async function DM(e) {\n      $i.logging.logWarn(\"SCIM response error\", e);\n    }"
    },
    "plugins": {
      "checkPluginQuotas": "async function rO() {\n      let e = J.tenancy.getGlobalDB();\n      try {\n        let r = (await e.allDocs(J.db.getPluginParams())).rows.length;\n        console.log(`Syncing plugin count: ${r}`), await vs(r);\n      } catch (t) {\n        J.logging.logAlert(\"Unable to retrieve plugins for quota check\", t);\n      }\n    }",
      "deletePlugin": "async function tO(e) {\n      let t = J.tenancy.getGlobalDB();\n      try {\n        let r = await t.get(e), a = J.objectStore.getPluginS3Dir(r.name);\n        await J.objectStore.deleteFolder(J.objectStore.ObjectStoreBuckets.PLUGINS, a), await t.remove(e, r._rev), await J.events.plugin.deleted(r), await Ts();\n      } catch (r) {\n        let a = r?.message ? r?.message : r;\n        throw new Error(`Failed to delete plugin: ${a}`);\n      }\n    }",
      "storePlugin": "async function eO(metadata, directory, source) {\n      let db = J.tenancy.getGlobalDB(), version = metadata.package.version, name = metadata.package.name, description = metadata.package.description, hash = metadata.schema.hash, bucketPath = J.objectStore.getPluginS3Dir(name), files = await J.objectStore.uploadDirectory(J.objectStore.ObjectStoreBuckets.PLUGINS, directory, bucketPath), jsFile = files.find((e) => e.name.endsWith(\".js\")), iconFile = files.find((e) => e.name.endsWith(\".svg\"));\n      if (!jsFile)\n        throw new Error(\"Plugin missing .js file.\");\n      if (metadata.schema.type === $f.PluginType.DATASOURCE) {\n        let js = Wf(directory, jsFile.name);\n        try {\n          eval(js);\n        } catch (e) {\n          let t = e?.message ? e.message : JSON.stringify(e);\n          throw new Error(`JS invalid: ${t}`);\n        }\n      }\n      let iconFileName = iconFile ? iconFile.name : null, pluginId = J.db.generatePluginID(name), rev;\n      try {\n        rev = (await db.get(pluginId))._rev;\n      } catch (e) {\n        rev = void 0;\n      }\n      let doc = { _id: pluginId, _rev: rev, ...metadata, name, version, hash, description, source };\n      iconFileName && (doc.iconFileName = iconFileName), source && (doc = { ...doc, source });\n      let write = async () => {\n        let e = await db.put(doc);\n        return await J.events.plugin.imported(doc), { ...doc, _rev: e.rev };\n      };\n      return rev ? await write() : await ws(write);\n    }"
    },
    "publicApi": {
      "applications": {
        "buildExportFn": "function vO(e) {\n      return async (t, r) => {\n        await tt() || t.throw(403, \"Endpoint unavailable, license required.\");\n        let { encryptPassword: a, excludeRows: n } = t.request.body;\n        await $s.context.doInAppContext(t.params.appId, async () => {\n          t.request.body = { encryptPassword: a, excludeRows: n }, t.query.appId = t.params.appId, await e(t), await r();\n        });\n      };\n    }",
        "buildImportFn": "function TO(e) {\n      return async (t, r) => {\n        await tt() || t.throw(403, \"Endpoint unavailable, license required.\"), t.request.files?.appExport || t.throw(400, \"Must provide app export file for import.\"), await $s.context.doInAppContext(t.params.appId, async () => {\n          await e(t), t.body = void 0, t.status = 204, await r();\n        });\n      };\n    }"
      },
      "roles": {
        "assign": "async function SO(e, t) {\n      if (!await tt())\n        throw new Error(\"Unable to assign roles - license required.\");\n      let r = await Ve.bulkGet(e);\n      for (let a of r) {\n        if (t.role && t.role.roleId) {\n          let n = wa.db.getProdAppID(t.role.appId);\n          a.roles[n] = t.role.roleId;\n        }\n        if (t.appBuilder) {\n          let n = wa.db.getProdAppID(t.appBuilder.appId), o = a.builder?.apps || [];\n          a.builder = { apps: o.concat([n]) };\n        }\n        t.builder && (a.builder = { global: true }), t.admin && (a.admin = { global: true }), a.roles;\n      }\n      await Ve.bulkUpdate(r);\n    }",
        "unAssign": "async function wO(e, t) {\n      if (!await tt())\n        throw new Error(\"Unable to un-assign roles - license required.\");\n      let r = await Ve.bulkGet(e);\n      for (let a of r) {\n        if (t.role) {\n          let n = wa.db.getProdAppID(t.role?.appId);\n          a.roles[n] === t.role.roleId && delete a.roles[n];\n        }\n        if (t.appBuilder && a.builder?.apps) {\n          let n = wa.db.getProdAppID(t.appBuilder.appId);\n          a.builder.apps = a.builder.apps.filter((o) => o !== n);\n        }\n        t.builder && a.builder && delete a.builder, t.admin && a.admin && delete a.admin;\n      }\n    }"
      },
      "users": {
        "roleCheck": "async function IO(e, t) {\n      return await tt() || bO(e, t), e;\n    }"
      }
    },
    "quotas": {
      "addAction": "async (e) => Ae(bn.MonthlyQuotaName.ACTIONS, bn.QuotaUsageType.MONTHLY, { fn: e })",
      "addApp": "async (e, { appId: t } = {}) => Ae(ur.StaticQuotaName.APPS, ur.QuotaUsageType.STATIC, { fn: e, valueFn: _f, id: t })",
      "addAutomation": "async (e, { automationId: t } = {}) => Ae(In.MonthlyQuotaName.AUTOMATIONS, In.QuotaUsageType.MONTHLY, { fn: e, id: t })",
      "addGroup": "async (e) => Ae(pr.StaticQuotaName.USER_GROUPS, pr.QuotaUsageType.STATIC, { fn: e })",
      "addPlugin": "async (e) => Ae(ht.StaticQuotaName.PLUGINS, ht.QuotaUsageType.STATIC, { fn: e })",
      "addRow": "async (e, { tableId: t } = {}) => Ae(We.StaticQuotaName.ROWS, We.QuotaUsageType.STATIC, { fn: e, id: t })",
      "addRows": "async (e, t, { tableId: r } = {}) => Pt({ change: e, name: We.StaticQuotaName.ROWS, type: We.QuotaUsageType.STATIC, opts: { fn: t, id: r } })",
      "addUsers": "async (e, t, r) => {\n      let a = [{ change: e, name: $e.StaticQuotaName.USERS, type: $e.QuotaUsageType.STATIC, opts: { fn: r, valueFn: ya.users.getUserCount } }];\n      t > 0 && a.push({ change: t, name: $e.StaticQuotaName.CREATORS, type: $e.QuotaUsageType.STATIC, opts: { valueFn: ya.users.getCreatorCount } });\n      let n = await Pt(a);\n      return await Wt(), n;\n    }",
      "bustCache": "async function mo(e = 0) {\n      let r = Fa(), a = Er(), n = await r.tryGet(a);\n      n && n._rev && await r.remove(a, n._rev).catch(async (o) => {\n        if (e < 1)\n          return await mo(e + 1);\n        throw o;\n      });\n    }",
      "decrement": "(e, t, r = {}) => ir({ usageChange: -1, name: e, type: t, opts: r })",
      "decrementMany": "(e) => {\n      let t = Array.isArray(e) ? e : [e];\n      return ir(t.map((r) => ({ usageChange: -r.change, name: r.name, type: r.type, opts: r.opts })));\n    }",
      "getCurrentUsageValues": "async (e, t, r) => {\n      let a = await Tt(), n = 0, o = {};\n      switch (e) {\n        case ne.QuotaUsageType.STATIC:\n          if (a.usageQuota[t]) {\n            let s = t;\n            n = a.usageQuota[s], o = Vu(a, e, t, r);\n          }\n          break;\n        case ne.QuotaUsageType.MONTHLY: {\n          let s = ct(), i = t;\n          a.monthly[s][i] && (n = a.monthly[s][i], o = Vu(a, e, t, r));\n          break;\n        }\n        default:\n          throw new Error(`Invalid usage type: ${e}`);\n      }\n      return ne.APP_QUOTA_NAMES.includes(t) && !(o.app || o.breakdown) && (o.app = o.app || 0, o.breakdown = o.breakdown || 0), { total: n, app: o.app, breakdown: o.breakdown };\n    }",
      "getLicensedQuota": "async (e, t, r) => {\n      let a = await Pe.getCachedLicense();\n      if (!a) {\n        let n = De.tenancy.getTenantId();\n        throw new Error(\"License not found for tenant id \" + n);\n      }\n      if (r && (0, z.isStaticQuota)(e, r, t))\n        return a.quotas[e][r][t];\n      if (r && (0, z.isMonthlyQuota)(e, r, t))\n        return a.quotas[e][r][t];\n      if ((0, z.isConstantQuota)(e, t))\n        return a.quotas[e][t];\n      throw new Error(\"Invalid quota type\");\n    }",
      "getQuotaUsage": "async () => {\n      let e = Fa(), t = await e.tryGet(Er());\n      if (!t) {\n        t = fo();\n        let { rev: r } = await e.put(t);\n        t._rev = r;\n      }\n      return Ga(t), lo(t), MI(t);\n    }",
      "increment": "(e, t, r) => vf({ change: 1, name: e, type: t, opts: r })",
      "incrementBudibaseAICredits": "async (e) => Pt({ change: e, name: wn.MonthlyQuotaName.BUDIBASE_AI_CREDITS, type: wn.QuotaUsageType.MONTHLY })",
      "incrementMany": "(e) => sr.tracer.trace(\"quotas.incrementMany\", async () => vf(e))",
      "removeApp": "async ({ appId: e } = {}) => rt(ur.StaticQuotaName.APPS, ur.QuotaUsageType.STATIC, { valueFn: _f, id: e })",
      "removeGroup": "async () => rt(pr.StaticQuotaName.USER_GROUPS, pr.QuotaUsageType.STATIC)",
      "removePlugin": "async () => rt(ht.StaticQuotaName.PLUGINS, ht.QuotaUsageType.STATIC)",
      "removeRow": "async ({ tableId: e } = {}) => rt(We.StaticQuotaName.ROWS, We.QuotaUsageType.STATIC, { id: e })",
      "removeRows": "async (e, { tableId: t } = {}) => ga({ change: e, name: We.StaticQuotaName.ROWS, type: We.QuotaUsageType.STATIC, opts: { id: t } })",
      "removeUsers": "async (e, t) => {\n      let r = [{ change: e, name: $e.StaticQuotaName.USERS, type: $e.QuotaUsageType.STATIC, opts: { valueFn: ya.users.getUserCount } }];\n      t > 0 && r.push({ change: t, name: $e.StaticQuotaName.CREATORS, type: $e.QuotaUsageType.STATIC, opts: { valueFn: ya.users.getCreatorCount } }), await ga(r), await Wt();\n    }",
      "set": "async (e, t, r) => ke.setUsage(r, e, t)",
      "setAllUsage": "async (e) => {\n      let t = Array.isArray(e) ? e : [e], r = Fa(), a = await Tt();\n      for (let o of t)\n        a = zu(a, o.name, o.type, o.values, o.opts);\n      let n = await r.put(a, 0);\n      return a._rev = n.rev, a;\n    }",
      "setAppUsageValue": "(e, t, r, a = {}, n) => {\n      let o;\n      try {\n        o = ce.db.getProdAppID(a?.appId || ce.context.getAppId());\n      } catch {\n      }\n      if (!o || !n.app || !ne.APP_QUOTA_NAMES.includes(t))\n        return e;\n      e.apps?.[o] || (e.apps = { ...e.apps, [o]: Ma() });\n      let s = e.apps[o];\n      switch (r) {\n        case ne.QuotaUsageType.STATIC:\n          s.usageQuota[t] = n.app;\n          break;\n        case ne.QuotaUsageType.MONTHLY: {\n          let i = ct(), p = t, f = s.monthly[i];\n          f || (s.monthly[i] = Rr(), f = s.monthly[i]), f[p] = n.app, ne.BREAKDOWN_QUOTA_NAMES.includes(p) && a?.id && (f = GI(f, p, a.id, n));\n          break;\n        }\n      }\n      return e;\n    }",
      "setUsage": "async (e, t, r) => yo({ name: t, type: r, values: { total: e } })",
      "setUsagePerApp": "async (e, t, r) => {\n      let a = Fa(), n = await Tt(), o = Object.values(e).reduce((i, p) => i + p, 0);\n      for (let [i, p] of Object.entries(e))\n        n = zu(n, t, r, { total: o, app: p }, { appId: i });\n      let s = await a.put(n);\n      return n._rev = s.rev, n;\n    }",
      "updatePluginCount": "async (e) => bs(ht.StaticQuotaName.PLUGINS, ht.QuotaUsageType.STATIC, e)",
      "updateUsage": "async (e) => {\n      await sr.tracer.trace(\"quotas.updateUsage\", async (t) => {\n        let r = De.tenancy.getTenantId(), a = Array.isArray(e) ? e : [e];\n        t.addTags({ numActions: a.length, tenantId: r });\n        let n, o, s = [], i = {}, p = {}, f = {}, m = {};\n        for (let g of a)\n          await sr.tracer.trace(\"quotas.updateUsage.action\", async (I) => {\n            I.addTags({ actionName: g.name, actionType: g.type, actionUsageChange: g.usageChange });\n            try {\n              n = De.context.getAppId();\n            } catch {\n            }\n            if (z.APP_QUOTA_NAMES.includes(g.name) && !n)\n              throw new Error(\"App context required for quota update\");\n            try {\n              o = await Ef(z.QuotaType.USAGE, g.name, g.type), s.push(o);\n              let { total: _6, app: R, breakdown: E } = await ke.getCurrentUsageValues(g.type, g.name, g.opts?.id);\n              _6 += g.usageChange, R != null && (R += g.usageChange), E != null && (E += g.usageChange);\n              let U = {};\n              if (g.opts?.dryRun || (U = await xx(g.type, g.name, _6, o), m = { ...m, [g.name]: U }), o.value !== Ze.UNLIMITED && _6 > o.value && g.usageChange > 0)\n                throw new De.UsageLimitError(`Licensed ${o.name} of ${o.value} has been exceeded`, o.name);\n              if (_6 = Math.max(0, _6), R && (R = Math.max(0, R)), E && (E = Math.max(0, E), f = { ...f, [g.name]: E }), !g.opts?.dryRun) {\n                let Le = g.opts?.valueFn;\n                Le && (_6 = await Le(), R = _6), i = { ...i, [g.name]: _6 }, p = { ...p, [g.name]: R };\n              }\n            } catch (_6) {\n              throw g.opts?.suppressErrorLog || console.error(`Error updating usage quotas for ${g.name}`, _6), _6;\n            }\n          });\n        let y = a.filter((g) => !g.opts?.dryRun).map((g) => ({ name: g.name, type: g.type, values: { total: i[g.name], app: p[g.name], breakdown: f[g.name], triggers: m[g.name] }, opts: { ...g.opts, tenantId: r } }));\n        y.length > 0 && await ke.setAllUsage(y);\n      });\n    }",
      "usageLimitIsExceeded": "async (e, t) => {\n      try {\n        return await ir({ usageChange: 1, name: e, type: t, opts: { dryRun: true } }), false;\n      } catch (r) {\n        if (r.code === z.ErrorCode.USAGE_LIMIT_EXCEEDED)\n          return true;\n        throw r;\n      }\n    }",
      "utils": {
        "generateBaseQuotaUsage": "() => ({ usageQuota: { [H.StaticQuotaName.APPS]: 0, [H.StaticQuotaName.ROWS]: 0, [H.StaticQuotaName.PLUGINS]: 0, [H.StaticQuotaName.USERS]: 0, [H.StaticQuotaName.CREATORS]: 0, [H.StaticQuotaName.USER_GROUPS]: 0, [H.StaticQuotaName.AI_CUSTOM_CONFIGS]: 0, triggers: {} }, monthly: { [ct()]: Rr() } })",
        "generateNewMonthlyQuotas": "() => ({ [H.MonthlyQuotaName.QUERIES]: 0, [H.MonthlyQuotaName.AUTOMATIONS]: 0, [H.MonthlyQuotaName.BUDIBASE_AI_CREDITS]: 0, [H.MonthlyQuotaName.ACTIONS]: 0, triggers: {} })",
        "generateNewQuotaUsage": "() => {\n      let e = { _id: Er(), quotaReset: Wu(), ...Ma(), apps: {} };\n      return Ga(e), e;\n    }",
        "getBreakdownName": "(e, t) => {\n      if (!(!t || !e))\n        switch (e) {\n          case H.MonthlyQuotaName.AUTOMATIONS:\n            return H.BreakdownQuotaName.AUTOMATIONS;\n          case H.MonthlyQuotaName.QUERIES:\n            return (0, Ba.isTableIdOrExternalTableId)(t) ? H.BreakdownQuotaName.ROW_QUERIES : (0, Ba.isDatasourceOrDatasourcePlusId)(t) ? H.BreakdownQuotaName.DATASOURCE_QUERIES : void 0;\n        }\n    }",
        "getCurrentMonthString": "() => {\n      let e = /* @__PURE__ */ new Date(), t = e.getMonth() + 1, r = e.getFullYear();\n      return `${t}-${r}`;\n    }",
        "getQuotaDocId": "() => vr.context.isSelfHostUsingCloud() ? `quota_usage_${vr.context.getTenantId()}` : vr.db.StaticDatabases.GLOBAL.docs.usageQuota",
        "setCurrentMonth": "(e) => {\n      let t = ct();\n      e.monthly || (e.monthly = {}), e.monthly[t] || (e.monthly[t] = Rr()), e.monthly.current = e.monthly[t];\n    }",
        "setQuotaReset": "(e) => {\n      e.quotaReset = Wu();\n    }"
      }
    },
    "scimGroups": {
      "create": "async function UM(e) {\n      let t = await Ao(e.name), r;\n      if (!t)\n        r = (await j.save(e)).id;\n      else {\n        if (t.scimInfo?.isSync)\n          throw new UA.HTTPError(\"Group is already synched\", 409);\n        r = t._id, t.users && (await j.removeUsers(r, t.users.map((n) => n._id)), delete t.users), t.scimInfo = (0, PA.default)(t.scimInfo, e.scimInfo), await j.save(t);\n      }\n      return await j.get(r);\n    }"
    },
    "scimUsers": {
      "create": "async function LM(e) {\n      let t = await Ve.getUserByEmail(e.email);\n      if (t) {\n        if (t.scimInfo?.isSync)\n          throw new st.HTTPError(\"User is already synched\", 409);\n        e = { ...t, scimInfo: (0, LA.default)(t.scimInfo, e.scimInfo), password: void 0, firstName: e.firstName, lastName: e.lastName, updatedAt: e.updatedAt };\n      }\n      return await Ve.save(e, { requirePassword: false });\n    }",
      "find": "async function OM(e) {\n      return await st.users.getById(e);\n    }",
      "get": "async function xM(e) {\n      let t = st.tenancy.getGlobalDB(), r = new st.db.QueryBuilder(t.name, CA.SearchIndex.USER);\n      r.setIndexBuilder(st.db.searchIndexes.createUserIndex), r.setLimit(e.pageSize), r.addEqual(\"scimInfo.isSync\", true);\n      for (let [n, o] of Object.entries(e.filters?.equal ?? {}))\n        r.addEqual(n, o);\n      r.setSort(\"_id\"), r.setSkip(e.skip);\n      let a = await r.run();\n      return { users: a.rows, total: a.totalRows };\n    }",
      "remove": "async function PM(e) {\n      return await Ve.destroy(e);\n    }",
      "update": "async function CM(e, t) {\n      return await Ve.save(e, { requirePassword: false, allowChangingEmail: t?.allowChangingEmail });\n    }"
    },
    "users": {
      "addAppBuilder": "async function Qx(e, t) {\n      if (!await Ct())\n        throw new Error(\"Feature not enabled, please check license\");\n      await Aa.users.addAppBuilder(e, t);\n    }",
      "db": "class _UserDB {\n      static init(quotaFns, groupFns, featureFns) {\n        _UserDB.quotas = quotaFns;\n        _UserDB.groups = groupFns;\n        _UserDB.features = featureFns;\n      }\n      static async isPreventPasswordActions(user, account) {\n        if (environment_default.ENABLE_SSO_MAINTENANCE_MODE && isAdmin2(user)) {\n          return false;\n        }\n        if (await _UserDB.features.isSSOEnforced()) {\n          return true;\n        }\n        if (isSSOUser(user)) {\n          return true;\n        }\n        if (!account) {\n          account = await getAccountByTenantId(getTenantId());\n        }\n        return !!(account && account.email === user.email && isSSOAccount(account));\n      }\n      static async buildUser(user, opts = {\n        hashPassword: true,\n        requirePassword: true\n      }, tenantId, dbUser, account) {\n        let { password, _id } = user;\n        if (dbUser && !dbUser.password) {\n          opts.requirePassword = false;\n        }\n        let hashedPassword;\n        if (password) {\n          if (await _UserDB.isPreventPasswordActions(user, account)) {\n            throw new HTTPError(\"Password change is disabled for this user\", 400);\n          }\n          if (!opts.skipPasswordValidation) {\n            const passwordValidation = validatePassword(password);\n            if (!passwordValidation.valid) {\n              throw new HTTPError(passwordValidation.error, 400);\n            }\n          }\n          hashedPassword = opts.hashPassword ? await hash2(password) : password;\n        } else if (dbUser) {\n          hashedPassword = dbUser.password;\n        }\n        const requirePasswords = opts.requirePassword && !await _UserDB.features.isSSOEnforced();\n        if (!hashedPassword && requirePasswords) {\n          throw \"Password must be specified.\";\n        }\n        _id = _id || generateGlobalUserID();\n        const fullUser = {\n          createdAt: Date.now(),\n          ...dbUser,\n          ...user,\n          _id,\n          password: hashedPassword,\n          tenantId\n        };\n        if (!fullUser.roles) {\n          fullUser.roles = {};\n        }\n        if (fullUser.status == null) {\n          fullUser.status = \"active\" /* ACTIVE */;\n        }\n        return fullUser;\n      }\n      static async allUsers() {\n        const db3 = getGlobalDB();\n        const response = await db3.allDocs(\n          getGlobalUserParams(null, {\n            include_docs: true\n          })\n        );\n        return response.rows.map((row) => row.doc);\n      }\n      static async countUsersByApp(appId) {\n        let response = await searchGlobalUsersByApp(appId, {});\n        return {\n          userCount: response.length\n        };\n      }\n      static async getUsersByAppAccess(opts) {\n        let response = await searchGlobalUsersByAppAccess(\n          opts.appId,\n          { limit: opts.limit || 50 }\n        );\n        return response;\n      }\n      static async getUserByEmail(email) {\n        return getGlobalUserByEmail(email);\n      }\n      /**\n       * Gets a user by ID from the global database, based on the current tenancy.\n       */\n      static async getUser(userId) {\n        const user = await getById(userId);\n        if (user) {\n          delete user.password;\n        }\n        return user;\n      }\n      static async bulkGet(userIds) {\n        return await bulkGetGlobalUsersById(userIds);\n      }\n      static async bulkUpdate(users2) {\n        return await bulkUpdateGlobalUsers(users2);\n      }\n      static async save(user, opts = {}) {\n        if (opts.hashPassword == null) {\n          opts.hashPassword = true;\n        }\n        if (opts.requirePassword == null) {\n          opts.requirePassword = true;\n        }\n        const tenantId = getTenantId();\n        const db3 = getGlobalDB();\n        const { email, _id, userGroups = [], roles } = user;\n        if (!email && !_id) {\n          throw new Error(\"_id or email is required\");\n        }\n        let dbUser;\n        if (_id) {\n          try {\n            dbUser = await getById(_id);\n            if (email && dbUser.email !== email && !opts.allowChangingEmail) {\n              throw new Error(\"Email address cannot be changed\");\n            }\n          } catch (e) {\n            if (e.status === 404) {\n            } else {\n              throw e;\n            }\n          }\n        }\n        if (!dbUser && email) {\n          dbUser = await getGlobalUserByEmail(email);\n          if (dbUser && dbUser._id !== _id) {\n            throw new EmailUnavailableError(email);\n          }\n        }\n        let change = 1;\n        let creatorsChange = 0;\n        if (opts.isAccountHolder || dbUser) {\n          change = 0;\n          creatorsChange = 1;\n        }\n        if (dbUser) {\n          const [isDbUserCreator, isUserCreator] = await creatorsInList([\n            dbUser,\n            user\n          ]);\n          creatorsChange = isDbUserCreator !== isUserCreator ? 1 : 0;\n        }\n        return _UserDB.quotas.addUsers(change, creatorsChange, async () => {\n          if (!opts.isAccountHolder) {\n            await validateUniqueUser(email, tenantId);\n          }\n          let builtUser = await _UserDB.buildUser(user, opts, tenantId, dbUser);\n          if (opts.currentUserId && opts.currentUserId === dbUser?._id) {\n            builtUser = cleanseUserObject(builtUser, dbUser);\n          }\n          if (!dbUser && roles?.length) {\n            builtUser.roles = { ...roles };\n          }\n          const groupPromises = [];\n          if (!_id) {\n            if (userGroups.length > 0) {\n              for (let groupId of userGroups) {\n                groupPromises.push(\n                  _UserDB.groups.addUsers(groupId, [builtUser._id])\n                );\n              }\n            }\n          }\n          try {\n            let response = await db3.put(builtUser);\n            builtUser._rev = response.rev;\n            await handleSaveEvents(builtUser, dbUser);\n            if (dbUser && builtUser.email !== dbUser.email) {\n              await users_exports2.removeUser({ email: dbUser.email });\n            }\n            await users_exports2.addUser(\n              tenantId,\n              builtUser._id,\n              builtUser.email,\n              builtUser.ssoId\n            );\n            await user_exports.invalidateUser(response.id);\n            await Promise.all(groupPromises);\n            return db3.get(builtUser._id);\n          } catch (err) {\n            if (err.status === 409) {\n              throw \"User exists already\";\n            } else {\n              throw err;\n            }\n          }\n        });\n      }\n      static async bulkCreate(newUsersRequested, groups4) {\n        const tenantId = getTenantId();\n        let usersToSave = [];\n        let newUsers = [];\n        let newCreators = [];\n        const emails = newUsersRequested.map((user) => user.email);\n        const existingEmails = await searchExistingEmails(emails);\n        const unsuccessful = [];\n        for (const newUser of newUsersRequested) {\n          const duplicateUser = newUsers.find(\n            (user) => user.email.toLowerCase() === newUser.email.toLowerCase()\n          );\n          const userExists = existingEmails.includes(newUser.email.toLowerCase());\n          if (duplicateUser || userExists) {\n            unsuccessful.push({ email: newUser.email, reason: `Unavailable` });\n            continue;\n          }\n          newUser.userGroups = groups4 || [];\n          newUsers.push(newUser);\n          if (await isCreatorAsync(newUser)) {\n            newCreators.push(newUser);\n          }\n        }\n        const account = await getAccountByTenantId(tenantId);\n        const isSSOEnforced = await _UserDB.features.isSSOEnforced();\n        return _UserDB.quotas.addUsers(\n          newUsers.length,\n          newCreators.length,\n          async () => {\n            for (const user of newUsers) {\n              if (isSSOEnforced) {\n                delete user.password;\n              }\n              usersToSave.push(\n                _UserDB.buildUser(\n                  user,\n                  { hashPassword: true, requirePassword: !isSSOEnforced },\n                  tenantId,\n                  void 0,\n                  account\n                )\n              );\n            }\n            const usersToBulkSave = await Promise.all(usersToSave);\n            await bulkUpdateGlobalUsers(usersToBulkSave);\n            for (const user of usersToBulkSave) {\n              await users_exports2.addUser(tenantId, user._id, user.email);\n              await handleSaveEvents(user, void 0);\n            }\n            const saved = usersToBulkSave.map((user) => {\n              return {\n                _id: user._id,\n                email: user.email\n              };\n            });\n            if (Array.isArray(saved) && groups4) {\n              const groupPromises = [];\n              const createdUserIds = saved.map((user) => user._id);\n              for (let groupId of groups4) {\n                groupPromises.push(_UserDB.groups.addUsers(groupId, createdUserIds));\n              }\n              await Promise.all(groupPromises);\n            }\n            return {\n              successful: saved,\n              unsuccessful\n            };\n          }\n        );\n      }\n      static async bulkDelete(users2) {\n        const db3 = getGlobalDB();\n        const response = {\n          successful: [],\n          unsuccessful: []\n        };\n        const accountHolder = await getAccountHolderFromUsers(users2);\n        if (accountHolder) {\n          users2 = users2.filter((u2) => u2.userId !== accountHolder.userId);\n          response.unsuccessful.push({\n            _id: accountHolder.userId,\n            email: accountHolder.email,\n            reason: \"Account holder cannot be deleted\"\n          });\n        }\n        const allDocsResponse = await db3.allDocs({\n          include_docs: true,\n          keys: users2.map((u2) => u2.userId)\n        });\n        const usersToDelete = allDocsResponse.rows.map((user) => {\n          return user.doc;\n        });\n        const toDelete = usersToDelete.map((user) => ({\n          ...user,\n          _deleted: true\n        }));\n        const dbResponse = await bulkUpdateGlobalUsers(toDelete);\n        const creatorsEval = await creatorsInList(usersToDelete);\n        const creatorsToDeleteCount = creatorsEval.filter((creator) => creator).length;\n        const ssoUsersToDelete = [];\n        for (let user of usersToDelete) {\n          const platformUser = await getFirstPlatformUser(\n            user._id\n          );\n          const ssoId = platformUser.ssoId;\n          if (ssoId) {\n            const ssoUsers = await getPlatformUsers(\n              ssoId\n            );\n            ssoUsers.filter((user2) => user2.ssoId == null).forEach((user2) => {\n              ssoUsersToDelete.push({\n                ...user2,\n                _deleted: true\n              });\n            });\n          }\n          await bulkDeleteProcessing(user);\n        }\n        await getPlatformDB().bulkDocs(ssoUsersToDelete);\n        await _UserDB.quotas.removeUsers(toDelete.length, creatorsToDeleteCount);\n        const userIndex = {};\n        usersToDelete.reduce((prev, current) => {\n          prev[current._id] = current;\n          return prev;\n        }, userIndex);\n        dbResponse.forEach((item) => {\n          const email = userIndex[item.id].email;\n          if (item.ok) {\n            response.successful.push({ _id: item.id, email });\n          } else {\n            response.unsuccessful.push({\n              _id: item.id,\n              email,\n              reason: \"Database error\"\n            });\n          }\n        });\n        return response;\n      }\n      static async destroy(id) {\n        const db3 = getGlobalDB();\n        const dbUser = await db3.get(id);\n        const userId = dbUser._id;\n        if (!environment_default.SELF_HOSTED && !environment_default.DISABLE_ACCOUNT_PORTAL) {\n          const email = dbUser.email;\n          const account = await getAccount(email);\n          if (account) {\n            if (dbUser.userId === getIdentity()._id) {\n              throw new HTTPError('Please visit \"Account\" to delete this user', 400);\n            } else {\n              throw new HTTPError(\"Account holder cannot be deleted\", 400);\n            }\n          }\n        }\n        await users_exports2.removeUser(dbUser);\n        await db3.remove(userId, dbUser._rev);\n        const creatorsToDelete = await isCreatorAsync(dbUser) ? 1 : 0;\n        await _UserDB.quotas.removeUsers(1, creatorsToDelete);\n        await handleDeleteEvents(dbUser);\n        await user_exports.invalidateUser(userId);\n        await invalidateSessions(userId, { reason: \"deletion\" });\n      }\n      static async createAdminUser(email, tenantId, opts) {\n        const password = opts?.password;\n        const user = {\n          email,\n          password,\n          createdAt: Date.now(),\n          roles: {},\n          builder: {\n            global: true\n          },\n          admin: {\n            global: true\n          },\n          tenantId,\n          firstName: opts?.firstName,\n          lastName: opts?.lastName\n        };\n        if (opts?.ssoId) {\n          user.ssoId = opts.ssoId;\n        }\n        await bustCache(CacheKey.CHECKLIST);\n        return await _UserDB.save(user, {\n          hashPassword: opts?.hashPassword,\n          requirePassword: opts?.requirePassword,\n          skipPasswordValidation: opts?.skipPasswordValidation,\n          isAccountHolder: true\n        });\n      }\n      static async getGroups(groupIds) {\n        return await this.groups.getBulk(groupIds);\n      }\n      static async getGroupBuilderAppIds(user) {\n        return await this.groups.getGroupBuilderAppIds(user);\n      }\n    }",
      "removeAppBuilder": "async function jx(e, t) {\n      if (!await Ct())\n        throw new Error(\"Feature not enabled, please check license\");\n      await Aa.users.removeAppBuilder(e, t);\n    }"
    },
    "utils": {
      "appExists": "async function xS(e) {\n      return (await vp.db.getAllApps({ all: true, idsOnly: true })).includes(e);\n    }",
      "encoding": {
        "base64ToObject": "function LS(e) {\n      let t = Buffer.from(e, \"base64\").toString();\n      return JSON.parse(t);\n    }",
        "objectToBase64": "function OS(e) {\n      let t = JSON.stringify(e);\n      return Buffer.from(t).toString(\"base64\");\n    }"
      }
    }
  },
  "users": {
    "addAppBuilder": "async function Qx(e, t) {\n      if (!await Ct())\n        throw new Error(\"Feature not enabled, please check license\");\n      await Aa.users.addAppBuilder(e, t);\n    }",
    "db": "class _UserDB {\n      static init(quotaFns, groupFns, featureFns) {\n        _UserDB.quotas = quotaFns;\n        _UserDB.groups = groupFns;\n        _UserDB.features = featureFns;\n      }\n      static async isPreventPasswordActions(user, account) {\n        if (environment_default.ENABLE_SSO_MAINTENANCE_MODE && isAdmin2(user)) {\n          return false;\n        }\n        if (await _UserDB.features.isSSOEnforced()) {\n          return true;\n        }\n        if (isSSOUser(user)) {\n          return true;\n        }\n        if (!account) {\n          account = await getAccountByTenantId(getTenantId());\n        }\n        return !!(account && account.email === user.email && isSSOAccount(account));\n      }\n      static async buildUser(user, opts = {\n        hashPassword: true,\n        requirePassword: true\n      }, tenantId, dbUser, account) {\n        let { password, _id } = user;\n        if (dbUser && !dbUser.password) {\n          opts.requirePassword = false;\n        }\n        let hashedPassword;\n        if (password) {\n          if (await _UserDB.isPreventPasswordActions(user, account)) {\n            throw new HTTPError(\"Password change is disabled for this user\", 400);\n          }\n          if (!opts.skipPasswordValidation) {\n            const passwordValidation = validatePassword(password);\n            if (!passwordValidation.valid) {\n              throw new HTTPError(passwordValidation.error, 400);\n            }\n          }\n          hashedPassword = opts.hashPassword ? await hash2(password) : password;\n        } else if (dbUser) {\n          hashedPassword = dbUser.password;\n        }\n        const requirePasswords = opts.requirePassword && !await _UserDB.features.isSSOEnforced();\n        if (!hashedPassword && requirePasswords) {\n          throw \"Password must be specified.\";\n        }\n        _id = _id || generateGlobalUserID();\n        const fullUser = {\n          createdAt: Date.now(),\n          ...dbUser,\n          ...user,\n          _id,\n          password: hashedPassword,\n          tenantId\n        };\n        if (!fullUser.roles) {\n          fullUser.roles = {};\n        }\n        if (fullUser.status == null) {\n          fullUser.status = \"active\" /* ACTIVE */;\n        }\n        return fullUser;\n      }\n      static async allUsers() {\n        const db3 = getGlobalDB();\n        const response = await db3.allDocs(\n          getGlobalUserParams(null, {\n            include_docs: true\n          })\n        );\n        return response.rows.map((row) => row.doc);\n      }\n      static async countUsersByApp(appId) {\n        let response = await searchGlobalUsersByApp(appId, {});\n        return {\n          userCount: response.length\n        };\n      }\n      static async getUsersByAppAccess(opts) {\n        let response = await searchGlobalUsersByAppAccess(\n          opts.appId,\n          { limit: opts.limit || 50 }\n        );\n        return response;\n      }\n      static async getUserByEmail(email) {\n        return getGlobalUserByEmail(email);\n      }\n      /**\n       * Gets a user by ID from the global database, based on the current tenancy.\n       */\n      static async getUser(userId) {\n        const user = await getById(userId);\n        if (user) {\n          delete user.password;\n        }\n        return user;\n      }\n      static async bulkGet(userIds) {\n        return await bulkGetGlobalUsersById(userIds);\n      }\n      static async bulkUpdate(users2) {\n        return await bulkUpdateGlobalUsers(users2);\n      }\n      static async save(user, opts = {}) {\n        if (opts.hashPassword == null) {\n          opts.hashPassword = true;\n        }\n        if (opts.requirePassword == null) {\n          opts.requirePassword = true;\n        }\n        const tenantId = getTenantId();\n        const db3 = getGlobalDB();\n        const { email, _id, userGroups = [], roles } = user;\n        if (!email && !_id) {\n          throw new Error(\"_id or email is required\");\n        }\n        let dbUser;\n        if (_id) {\n          try {\n            dbUser = await getById(_id);\n            if (email && dbUser.email !== email && !opts.allowChangingEmail) {\n              throw new Error(\"Email address cannot be changed\");\n            }\n          } catch (e) {\n            if (e.status === 404) {\n            } else {\n              throw e;\n            }\n          }\n        }\n        if (!dbUser && email) {\n          dbUser = await getGlobalUserByEmail(email);\n          if (dbUser && dbUser._id !== _id) {\n            throw new EmailUnavailableError(email);\n          }\n        }\n        let change = 1;\n        let creatorsChange = 0;\n        if (opts.isAccountHolder || dbUser) {\n          change = 0;\n          creatorsChange = 1;\n        }\n        if (dbUser) {\n          const [isDbUserCreator, isUserCreator] = await creatorsInList([\n            dbUser,\n            user\n          ]);\n          creatorsChange = isDbUserCreator !== isUserCreator ? 1 : 0;\n        }\n        return _UserDB.quotas.addUsers(change, creatorsChange, async () => {\n          if (!opts.isAccountHolder) {\n            await validateUniqueUser(email, tenantId);\n          }\n          let builtUser = await _UserDB.buildUser(user, opts, tenantId, dbUser);\n          if (opts.currentUserId && opts.currentUserId === dbUser?._id) {\n            builtUser = cleanseUserObject(builtUser, dbUser);\n          }\n          if (!dbUser && roles?.length) {\n            builtUser.roles = { ...roles };\n          }\n          const groupPromises = [];\n          if (!_id) {\n            if (userGroups.length > 0) {\n              for (let groupId of userGroups) {\n                groupPromises.push(\n                  _UserDB.groups.addUsers(groupId, [builtUser._id])\n                );\n              }\n            }\n          }\n          try {\n            let response = await db3.put(builtUser);\n            builtUser._rev = response.rev;\n            await handleSaveEvents(builtUser, dbUser);\n            if (dbUser && builtUser.email !== dbUser.email) {\n              await users_exports2.removeUser({ email: dbUser.email });\n            }\n            await users_exports2.addUser(\n              tenantId,\n              builtUser._id,\n              builtUser.email,\n              builtUser.ssoId\n            );\n            await user_exports.invalidateUser(response.id);\n            await Promise.all(groupPromises);\n            return db3.get(builtUser._id);\n          } catch (err) {\n            if (err.status === 409) {\n              throw \"User exists already\";\n            } else {\n              throw err;\n            }\n          }\n        });\n      }\n      static async bulkCreate(newUsersRequested, groups4) {\n        const tenantId = getTenantId();\n        let usersToSave = [];\n        let newUsers = [];\n        let newCreators = [];\n        const emails = newUsersRequested.map((user) => user.email);\n        const existingEmails = await searchExistingEmails(emails);\n        const unsuccessful = [];\n        for (const newUser of newUsersRequested) {\n          const duplicateUser = newUsers.find(\n            (user) => user.email.toLowerCase() === newUser.email.toLowerCase()\n          );\n          const userExists = existingEmails.includes(newUser.email.toLowerCase());\n          if (duplicateUser || userExists) {\n            unsuccessful.push({ email: newUser.email, reason: `Unavailable` });\n            continue;\n          }\n          newUser.userGroups = groups4 || [];\n          newUsers.push(newUser);\n          if (await isCreatorAsync(newUser)) {\n            newCreators.push(newUser);\n          }\n        }\n        const account = await getAccountByTenantId(tenantId);\n        const isSSOEnforced = await _UserDB.features.isSSOEnforced();\n        return _UserDB.quotas.addUsers(\n          newUsers.length,\n          newCreators.length,\n          async () => {\n            for (const user of newUsers) {\n              if (isSSOEnforced) {\n                delete user.password;\n              }\n              usersToSave.push(\n                _UserDB.buildUser(\n                  user,\n                  { hashPassword: true, requirePassword: !isSSOEnforced },\n                  tenantId,\n                  void 0,\n                  account\n                )\n              );\n            }\n            const usersToBulkSave = await Promise.all(usersToSave);\n            await bulkUpdateGlobalUsers(usersToBulkSave);\n            for (const user of usersToBulkSave) {\n              await users_exports2.addUser(tenantId, user._id, user.email);\n              await handleSaveEvents(user, void 0);\n            }\n            const saved = usersToBulkSave.map((user) => {\n              return {\n                _id: user._id,\n                email: user.email\n              };\n            });\n            if (Array.isArray(saved) && groups4) {\n              const groupPromises = [];\n              const createdUserIds = saved.map((user) => user._id);\n              for (let groupId of groups4) {\n                groupPromises.push(_UserDB.groups.addUsers(groupId, createdUserIds));\n              }\n              await Promise.all(groupPromises);\n            }\n            return {\n              successful: saved,\n              unsuccessful\n            };\n          }\n        );\n      }\n      static async bulkDelete(users2) {\n        const db3 = getGlobalDB();\n        const response = {\n          successful: [],\n          unsuccessful: []\n        };\n        const accountHolder = await getAccountHolderFromUsers(users2);\n        if (accountHolder) {\n          users2 = users2.filter((u2) => u2.userId !== accountHolder.userId);\n          response.unsuccessful.push({\n            _id: accountHolder.userId,\n            email: accountHolder.email,\n            reason: \"Account holder cannot be deleted\"\n          });\n        }\n        const allDocsResponse = await db3.allDocs({\n          include_docs: true,\n          keys: users2.map((u2) => u2.userId)\n        });\n        const usersToDelete = allDocsResponse.rows.map((user) => {\n          return user.doc;\n        });\n        const toDelete = usersToDelete.map((user) => ({\n          ...user,\n          _deleted: true\n        }));\n        const dbResponse = await bulkUpdateGlobalUsers(toDelete);\n        const creatorsEval = await creatorsInList(usersToDelete);\n        const creatorsToDeleteCount = creatorsEval.filter((creator) => creator).length;\n        const ssoUsersToDelete = [];\n        for (let user of usersToDelete) {\n          const platformUser = await getFirstPlatformUser(\n            user._id\n          );\n          const ssoId = platformUser.ssoId;\n          if (ssoId) {\n            const ssoUsers = await getPlatformUsers(\n              ssoId\n            );\n            ssoUsers.filter((user2) => user2.ssoId == null).forEach((user2) => {\n              ssoUsersToDelete.push({\n                ...user2,\n                _deleted: true\n              });\n            });\n          }\n          await bulkDeleteProcessing(user);\n        }\n        await getPlatformDB().bulkDocs(ssoUsersToDelete);\n        await _UserDB.quotas.removeUsers(toDelete.length, creatorsToDeleteCount);\n        const userIndex = {};\n        usersToDelete.reduce((prev, current) => {\n          prev[current._id] = current;\n          return prev;\n        }, userIndex);\n        dbResponse.forEach((item) => {\n          const email = userIndex[item.id].email;\n          if (item.ok) {\n            response.successful.push({ _id: item.id, email });\n          } else {\n            response.unsuccessful.push({\n              _id: item.id,\n              email,\n              reason: \"Database error\"\n            });\n          }\n        });\n        return response;\n      }\n      static async destroy(id) {\n        const db3 = getGlobalDB();\n        const dbUser = await db3.get(id);\n        const userId = dbUser._id;\n        if (!environment_default.SELF_HOSTED && !environment_default.DISABLE_ACCOUNT_PORTAL) {\n          const email = dbUser.email;\n          const account = await getAccount(email);\n          if (account) {\n            if (dbUser.userId === getIdentity()._id) {\n              throw new HTTPError('Please visit \"Account\" to delete this user', 400);\n            } else {\n              throw new HTTPError(\"Account holder cannot be deleted\", 400);\n            }\n          }\n        }\n        await users_exports2.removeUser(dbUser);\n        await db3.remove(userId, dbUser._rev);\n        const creatorsToDelete = await isCreatorAsync(dbUser) ? 1 : 0;\n        await _UserDB.quotas.removeUsers(1, creatorsToDelete);\n        await handleDeleteEvents(dbUser);\n        await user_exports.invalidateUser(userId);\n        await invalidateSessions(userId, { reason: \"deletion\" });\n      }\n      static async createAdminUser(email, tenantId, opts) {\n        const password = opts?.password;\n        const user = {\n          email,\n          password,\n          createdAt: Date.now(),\n          roles: {},\n          builder: {\n            global: true\n          },\n          admin: {\n            global: true\n          },\n          tenantId,\n          firstName: opts?.firstName,\n          lastName: opts?.lastName\n        };\n        if (opts?.ssoId) {\n          user.ssoId = opts.ssoId;\n        }\n        await bustCache(CacheKey.CHECKLIST);\n        return await _UserDB.save(user, {\n          hashPassword: opts?.hashPassword,\n          requirePassword: opts?.requirePassword,\n          skipPasswordValidation: opts?.skipPasswordValidation,\n          isAccountHolder: true\n        });\n      }\n      static async getGroups(groupIds) {\n        return await this.groups.getBulk(groupIds);\n      }\n      static async getGroupBuilderAppIds(user) {\n        return await this.groups.getGroupBuilderAppIds(user);\n      }\n    }",
    "removeAppBuilder": "async function jx(e, t) {\n      if (!await Ct())\n        throw new Error(\"Feature not enabled, please check license\");\n      await Aa.users.removeAppBuilder(e, t);\n    }"
  },
  "utils": {
    "appExists": "async function xS(e) {\n      return (await vp.db.getAllApps({ all: true, idsOnly: true })).includes(e);\n    }",
    "encoding": {
      "base64ToObject": "function LS(e) {\n      let t = Buffer.from(e, \"base64\").toString();\n      return JSON.parse(t);\n    }",
      "objectToBase64": "function OS(e) {\n      let t = JSON.stringify(e);\n      return Buffer.from(t).toString(\"base64\");\n    }"
    }
  }
}